<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D HyperCipher Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #2c3e50;
        }
        .panel {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #f9f9f9;
        }
        textarea, input[type="text"], input[type="password"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background: #2980b9;
        }
        .cube-view {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        .cube {
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            background: white;
        }
        .cube-layer {
            margin-bottom: 15px;
        }
        .cube-layer h4 {
            margin: 0 0 5px 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
            font-family: monospace;
        }
        .result {
            margin-top: 15px;
            padding: 10px;
            background: #e8f4fc;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>4D HyperCipher</h1>
        
        <div class="panel">
            <h2>Настройки</h2>
            <div>
                <label for="alphabet">Алфавит (54 символа):</label>
                <textarea id="alphabet" rows="3">ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_-+=[]{};:,.<>?</textarea>
            </div>
            <div>
                <label for="filler">Заполняющий символ:</label>
                <input type="text" id="filler" value="~" maxlength="1">
            </div>
            <div>
                <label for="key">Ключ:</label>
                <input type="password" id="key">
            </div>
            <div>
                <label for="rounds">Раундов (3-10):</label>
                <input type="number" id="rounds" min="3" max="10" value="5">
            </div>
            <button id="initBtn">Инициализировать кубы</button>
            <button id="resetBtn">Сбросить</button>
        </div>

        <div class="panel">
            <h2>Шифрование</h2>
            <textarea id="plaintext" placeholder="Текст для шифрования"></textarea>
            <button id="encryptBtn">Зашифровать</button>
            <div class="result" id="encryptResult"></div>
        </div>

        <div class="panel">
            <h2>Дешифрование</h2>
            <textarea id="ciphertext" placeholder="Текст для дешифрования"></textarea>
            <button id="decryptBtn">Дешифровать</button>
            <div class="result" id="decryptResult"></div>
        </div>

        <div class="panel">
            <h2>Гиперкубы</h2>
            <div class="cube-view" id="cubeView"></div>
        </div>
    </div>

    <script>
        class HyperCipher4D {
            constructor() {
                this.hypercubes = [];
                this.alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_-+=[]{};:,.<>?";
                this.fillerChar = "~";
                this.rounds = 5;
                this.salt = CryptoJS.lib.WordArray.random(16).toString();
                
                this.initEvents();
            }

            initEvents() {
                document.getElementById('initBtn').addEventListener('click', () => this.initCubes());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                document.getElementById('encryptBtn').addEventListener('click', () => this.encrypt());
                document.getElementById('decryptBtn').addEventListener('click', () => this.decrypt());
            }

            async initCubes() {
                const alphabet = document.getElementById('alphabet').value;
                const filler = document.getElementById('filler').value;
                const key = document.getElementById('key').value;
                const rounds = parseInt(document.getElementById('rounds').value);

                // Валидация
                if (alphabet.length !== 54) {
                    alert("Алфавит должен содержать ровно 54 символа");
                    return;
                }
                if (new Set(alphabet).size !== 54) {
                    alert("Алфавит содержит повторяющиеся символы");
                    return;
                }
                if (alphabet.includes(filler)) {
                    alert("Заполняющий символ не должен быть в алфавите");
                    return;
                }

                this.alphabet = alphabet;
                this.fillerChar = filler;
                this.rounds = rounds;

                try {
                    await this.generateHypercubes(key);
                    this.displayCubes();
                    alert(`Успешно создано ${this.rounds} раундов шифрования`);
                } catch (e) {
                    alert("Ошибка: " + e.message);
                }
            }

            async generateHypercubes(key) {
                this.hypercubes = [];
                let masterSeed;

                if (key) {
                    masterSeed = await this.deriveKey(key, this.salt, 100000);
                } else {
                    if (!confirm("Ключ не указан. Использовать стандартные кубы?")) return;
                    masterSeed = "default";
                }

                for (let round = 0; round < this.rounds; round++) {
                    const roundSeed = key ? await this.hmacSha256(masterSeed, round.toString()) : round.toString();
                    const hypercube = await this.createHypercube(roundSeed);
                    this.hypercubes.push(hypercube);
                }
            }

            async createHypercube(seed) {
                const shuffled = await this.shuffleAlphabet(this.alphabet, seed);
                return {
                    cube1: this.fillCube(shuffled.substring(0, 27)),
                    cube2: this.fillCube(shuffled.substring(27))
                };
            }

            fillCube(chars) {
                const cube = [];
                let pos = 0;
                
                for (let x = 0; x < 3; x++) {
                    cube[x] = [];
                    for (let y = 0; y < 3; y++) {
                        cube[x][y] = [];
                        for (let z = 0; z < 3; z++) {
                            cube[x][y][z] = chars[pos++ % chars.length];
                        }
                    }
                }
                
                return cube;
            }

            displayCubes() {
                const container = document.getElementById('cubeView');
                container.innerHTML = '';

                if (this.hypercubes.length === 0) return;

                // Показываем только первый раунд для наглядности
                const { cube1, cube2 } = this.hypercubes[0];
                
                container.appendChild(this.createCubeTable(cube1, "XYZ Cube"));
                container.appendChild(this.createCubeTable(cube2, "WXY Cube"));
            }

            createCubeTable(cube, title) {
                const div = document.createElement('div');
                div.className = 'cube';
                div.innerHTML = `<h3>${title}</h3>`;
                
                for (let z = 0; z < 3; z++) {
                    const layerDiv = document.createElement('div');
                    layerDiv.className = 'cube-layer';
                    layerDiv.innerHTML = `<h4>Слой Z=${z}</h4>`;
                    
                    const table = document.createElement('table');
                    for (let y = 0; y < 3; y++) {
                        const row = table.insertRow();
                        for (let x = 0; x < 3; x++) {
                            const cell = row.insertCell();
                            cell.textContent = cube[x][y][z];
                            cell.title = `X=${x}, Y=${y}, Z=${z}`;
                        }
                    }
                    
                    layerDiv.appendChild(table);
                    div.appendChild(layerDiv);
                }
                
                return div;
            }

            async encrypt() {
                const text = document.getElementById('plaintext').value;
                if (!text) {
                    alert("Введите текст для шифрования");
                    return;
                }
                if (this.hypercubes.length === 0) {
                    alert("Сначала инициализируйте кубы");
                    return;
                }

                try {
                    let result = text;
                    for (let round = 0; round < this.rounds; round++) {
                        result = this.processRound(result, round, true);
                    }
                    document.getElementById('encryptResult').textContent = result;
                } catch (e) {
                    alert("Ошибка шифрования: " + e.message);
                }
            }

            async decrypt() {
                const text = document.getElementById('ciphertext').value;
                if (!text) {
                    alert("Введите текст для дешифрования");
                    return;
                }
                if (this.hypercubes.length === 0) {
                    alert("Сначала инициализируйте кубы");
                    return;
                }

                try {
                    let result = text;
                    for (let round = this.rounds - 1; round >= 0; round--) {
                        result = this.processRound(result, round, false);
                    }
                    document.getElementById('decryptResult').textContent = result;
                } catch (e) {
                    alert("Ошибка дешифрования: " + e.message);
                }
            }

            processRound(text, round, isEncrypt) {
                const hypercube = this.hypercubes[round];
                let result = '';
                
                if (isEncrypt) {
                    // Шифрование
                    const coords = [];
                    
                    // 1. Получаем координаты всех символов
                    for (const char of text.toUpperCase()) {
                        const coord = this.findCharCoordinates(char, hypercube);
                        coords.push(coord || { x: 0, y: 0, z: 0, wx: 0, wy: 0, wz: 0, char });
                    }
                    
                    // 2. Собираем потоки координат
                    const xStream = [], yStream = [], zStream = [], wStream = [];
                    for (const {x, y, z, wx, wy, wz} of coords) {
                        xStream.push(x, wx);
                        yStream.push(y, wy);
                        zStream.push(z, wz);
                    }
                    
                    // 3. Объединяем потоки
                    const fullStream = [...xStream, ...yStream, ...zStream].join('');
                    
                    // 4. Разбиваем на триплеты и преобразуем в символы
                    for (let i = 0; i < fullStream.length; i += 3) {
                        const triplet = fullStream.substr(i, 3);
                        if (triplet.length === 3) {
                            const x = parseInt(triplet[0]);
                            const y = parseInt(triplet[1]);
                            const z = parseInt(triplet[2]);
                            result += hypercube.cube1[x][y][z] || this.fillerChar;
                        }
                    }
                } else {
                    // Дешифрование
                    const coords = [];
                    
                    // 1. Получаем координаты всех символов
                    for (const char of text.toUpperCase()) {
                        const coord = this.findCharCoordinates(char, hypercube);
                        if (coord) {
                            coords.push(coord);
                        } else {
                            result += char; // Пропускаем неизвестные символы
                        }
                    }
                    
                    // 2. Собираем полный поток координат
                    let fullStream = '';
                    for (const {x, y, z, wx, wy, wz} of coords) {
                        fullStream += x.toString() + y.toString() + z.toString() + wx.toString() + wy.toString() + wz.toString();
                    }
                    
                    // 3. Разделяем на оригинальные потоки
                    const mid = Math.floor(fullStream.length / 2);
                    const xStream = fullStream.substring(0, mid);
                    const yzStream = fullStream.substring(mid);
                    
                    // 4. Восстанавливаем символы
                    for (let i = 0; i < xStream.length; i += 3) {
                        const x = parseInt(xStream[i]);
                        const y = parseInt(yzStream[i]);
                        const z = parseInt(xStream[i+1]);
                        const wx = parseInt(yzStream[i+1]);
                        
                        result += hypercube.cube1[x][y][z] || this.fillerChar;
                    }
                }
                
                return result;
            }

            findCharCoordinates(char, hypercube) {
                // Ищем в первом кубе (XYZ)
                for (let x = 0; x < 3; x++) {
                    for (let y = 0; y < 3; y++) {
                        for (let z = 0; z < 3; z++) {
                            if (hypercube.cube1[x][y][z] === char) {
                                // Ищем соответствующий символ во втором кубе (WXY)
                                for (let wx = 0; wx < 3; wx++) {
                                    for (let wy = 0; wy < 3; wy++) {
                                        for (let wz = 0; wz < 3; wz++) {
                                            if (hypercube.cube2[wx][wy][wz] === char) {
                                                return { x, y, z, wx, wy, wz };
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return null;
            }

            reset() {
                document.getElementById('alphabet').value = this.alphabet;
                document.getElementById('filler').value = this.fillerChar;
                document.getElementById('key').value = '';
                document.getElementById('plaintext').value = '';
                document.getElementById('ciphertext').value = '';
                document.getElementById('encryptResult').textContent = '';
                document.getElementById('decryptResult').textContent = '';
                document.getElementById('cubeView').innerHTML = '';
                this.hypercubes = [];
            }

            async shuffleAlphabet(alphabet, seed) {
                const hash = CryptoJS.SHA256(seed).toString();
                const arr = alphabet.split('');
                let hashPos = 0;
                
                for (let i = arr.length - 1; i > 0; i--) {
                    const n = parseInt(hash.substr(hashPos, 2), 16);
                    hashPos = (hashPos + 2) % 64;
                    const j = n % (i + 1);
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                
                return arr.join('');
            }

            async deriveKey(password, salt, iterations) {
                return CryptoJS.PBKDF2(password, salt, {
                    keySize: 256/32,
                    iterations: iterations,
                    hasher: CryptoJS.algo.SHA256
                }).toString();
            }

            async hmacSha256(key, message) {
                return CryptoJS.HmacSHA256(message, key).toString();
            }
        }

        // Инициализация при загрузке
        document.addEventListener('DOMContentLoaded', () => {
            window.cipher = new HyperCipher4D();
        });
    </script>
</body>
</html>
