<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Trifid Cipher</title>
    <style>
        :root {
            --primary: #3498db;
            --secondary: #2ecc71;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --danger: #e74c3c;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--light);
            color: var(--dark);
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: var(--primary);
            margin-bottom: 10px;
        }
        
        .description {
            color: var(--dark);
            max-width: 800px;
            margin: 0 auto;
        }
        
        .app-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .panel-title {
            color: var(--primary);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        textarea {
            width: 100%;
            min-height: 150px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            font-family: monospace;
            margin-bottom: 15px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .btn {
            display: inline-block;
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        .btn:hover {
            background-color: #2980b9;
        }
        
        .btn-secondary {
            background-color: var(--secondary);
        }
        
        .btn-secondary:hover {
            background-color: #27ae60;
        }
        
        .btn-danger {
            background-color: var(--danger);
        }
        
        .btn-danger:hover {
            background-color: #c0392b;
        }
        
        .cubes-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }
        
        .cube-title {
            text-align: center;
            margin-bottom: 10px;
            color: var(--dark);
        }
        
        .cube {
            perspective: 1000px;
            margin: 0 auto;
            width: 200px;
            height: 200px;
        }
        
        .cube-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 1s;
        }
        
        .cube-face {
            position: absolute;
            width: 200px;
            height: 200px;
            border: 2px solid var(--dark);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            background-color: rgba(255,255,255,0.8);
            padding: 5px;
        }
        
        .cube-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ccc;
            font-weight: bold;
        }
        
        .cube-face-front {
            transform: translateZ(100px);
        }
        
        .cube-face-back {
            transform: rotateY(180deg) translateZ(100px);
        }
        
        .cube-face-right {
            transform: rotateY(90deg) translateZ(100px);
        }
        
        .cube-face-left {
            transform: rotateY(-90deg) translateZ(100px);
        }
        
        .cube-face-top {
            transform: rotateX(90deg) translateZ(100px);
        }
        
        .cube-face-bottom {
            transform: rotateX(-90deg) translateZ(100px);
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            background-color: #f8f9fa;
            font-family: monospace;
        }
        
        .error {
            color: var(--danger);
        }
        
        .success {
            color: var(--secondary);
        }
        
        .tab-container {
            margin-bottom: 20px;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            margin-right: 5px;
        }
        
        .tab.active {
            border-color: #ddd;
            border-bottom-color: white;
            background-color: white;
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
            padding: 20px;
            background-color: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .animation-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .rotation-slider {
            width: 100%;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>4D Trifid Cipher</h1>
            <p class="description">
                A 4-dimensional extension of the classic Trifid cipher using two 3D cubes for enhanced security.
                Enter your message, encryption key, and number of rounds to encrypt or decrypt text.
            </p>
        </header>
        
        <div class="tab-container">
            <div class="tabs">
                <div class="tab active" data-tab="cipher">Cipher Tool</div>
                <div class="tab" data-tab="cubes">Cube Visualization</div>
                <div class="tab" data-tab="about">About</div>
            </div>
            
            <div class="tab-content active" id="cipher">
                <div class="app-container">
                    <div class="panel">
                        <h2 class="panel-title">Input</h2>
                        <textarea id="inputText" placeholder="Enter your message here..."></textarea>
                        
                        <div class="form-group">
                            <label for="key">Encryption Key:</label>
                            <input type="text" id="key" placeholder="Enter secret key">
                        </div>
                        
                        <div class="form-group">
                            <label for="rounds">Rounds:</label>
                            <input type="number" id="rounds" min="1" max="10" value="3">
                        </div>
                        
                        <div class="form-group">
                            <label for="action">Action:</label>
                            <select id="action">
                                <option value="encrypt">Encrypt</option>
                                <option value="decrypt">Decrypt</option>
                            </select>
                        </div>
                        
                        <div class="controls">
                            <button id="processBtn" class="btn">Process</button>
                            <button id="clearBtn" class="btn btn-danger">Clear</button>
                        </div>
                    </div>
                    
                    <div class="panel">
                        <h2 class="panel-title">Output</h2>
                        <textarea id="outputText" readonly placeholder="Result will appear here..."></textarea>
                        
                        <div class="form-group">
                            <label>Status:</label>
                            <div id="status" class="status">Ready</div>
                        </div>
                        
                        <div class="controls">
                            <button id="copyBtn" class="btn btn-secondary">Copy to Clipboard</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="cubes">
                <h2 class="panel-title">Cube Visualization</h2>
                <p>Visual representation of the two 3D cubes used in the 4D Trifid cipher.</p>
                
                <div class="cubes-container">
                    <div>
                        <h3 class="cube-title">Primary Cube (XYZ)</h3>
                        <div class="cube" id="cube1">
                            <div class="cube-inner">
                                <div class="cube-face cube-face-front"></div>
                                <div class="cube-face cube-face-back"></div>
                                <div class="cube-face cube-face-right"></div>
                                <div class="cube-face cube-face-left"></div>
                                <div class="cube-face cube-face-top"></div>
                                <div class="cube-face cube-face-bottom"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="cube-title">Secondary Cube (WX WY WZ)</h3>
                        <div class="cube" id="cube2">
                            <div class="cube-inner">
                                <div class="cube-face cube-face-front"></div>
                                <div class="cube-face cube-face-back"></div>
                                <div class="cube-face cube-face-right"></div>
                                <div class="cube-face cube-face-left"></div>
                                <div class="cube-face cube-face-top"></div>
                                <div class="cube-face cube-face-bottom"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="animation-controls">
                    <button id="rotateXCube1" class="btn">Rotate X</button>
                    <button id="rotateYCube1" class="btn">Rotate Y</button>
                    <button id="rotateZCube1" class="btn">Rotate Z</button>
                    
                    <input type="range" id="rotationSlider" class="rotation-slider" min="0" max="360" value="0">
                </div>
                
                <div class="form-group">
                    <label>Current Cube State:</label>
                    <div id="cubeState" class="status">Cubes not initialized. Process a message to see the cubes.</div>
                </div>
            </div>
            
            <div class="tab-content" id="about">
                <h2 class="panel-title">About 4D Trifid Cipher</h2>
                
                <div class="panel">
                    <h3>Algorithm Overview</h3>
                    <p>
                        The 4D Trifid Cipher is an extension of the classic Trifid cipher that operates in four dimensions
                        using two interlocked 3D cubes. This provides significantly enhanced security compared to the
                        original 3D version.
                    </p>
                    
                    <h3>How It Works</h3>
                    <ol>
                        <li>Two 3×3×3 cubes are created from a shuffled alphabet (54 characters total)</li>
                        <li>Each character is located in both cubes, giving it 6 coordinates (x,y,z,wx,wy,wz)</li>
                        <li>For encryption, coordinates are interleaved (XWX YWY ZWZ) and converted back to characters</li>
                        <li>Multiple rounds can be applied for additional security</li>
                    </ol>
                    
                    <h3>Security Features</h3>
                    <ul>
                        <li>Uses cryptographically secure key derivation (PBKDF2)</li>
                        <li>Supports multiple rounds of encryption</li>
                        <li>Large key space makes brute force attacks impractical</li>
                        <li>4D coordinate system provides more confusion than standard 3D ciphers</li>
                    </ul>
                    
                    <h3>Implementation Notes</h3>
                    <p>
                        This implementation uses JavaScript's Web Crypto API for secure key derivation and
                        includes visualization of the 3D cubes to help understand the encryption process.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        class Trifid4D {
            constructor() {
                this.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,!?@#$%^&*()';
                this.fillerChar = 'X';
                this.hypercubes = [];
                this.currentRotation = { cube1: { x: 0, y: 0, z: 0 }, cube2: { x: 0, y: 0, z: 0 } };
            }
            
            async init(key, rounds) {
                this.hypercubes = [];
                const derivedKey = await this.deriveKey(key, rounds);
                
                for (let i = 0; i < rounds; i++) {
                    const roundKey = derivedKey.slice(i * 4, (i + 1) * 4);
                    const hypercube = await this.createHypercube(roundKey);
                    this.hypercubes.push(hypercube);
                }
            }
            
            async deriveKey(key, rounds) {
                const encoder = new TextEncoder();
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(key),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits']
                );
                
                const salt = encoder.encode('4DTrifidSalt');
                const derivedBits = await crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: 10000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    256
                );
                
                const derivedArray = Array.from(new Uint8Array(derivedBits));
                return derivedArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }
            
            async createHypercube(seed) {
                const shuffled = await this.shuffleAlphabet(this.alphabet, seed);
                return {
                    cube1: this.fill3DCube(shuffled.substring(0, 27)), // XYZ cube
                    cube2: this.fill3DCube(shuffled.substring(27)),    // WX WY WZ cube
                    coordinateMap: this.buildCoordinateMap(shuffled)
                };
            }
            
            buildCoordinateMap(shuffled) {
                const map = {};
                const cube1 = this.fill3DCube(shuffled.substring(0, 27));
                const cube2 = this.fill3DCube(shuffled.substring(27));
                
                for (let x = 0; x < 3; x++) {
                    for (let y = 0; y < 3; y++) {
                        for (let z = 0; z < 3; z++) {
                            const char = cube1[x][y][z];
                            if (!map[char]) map[char] = {};
                            map[char].cube1 = { x, y, z };
                        }
                    }
                }
                
                for (let wx = 0; wx < 3; wx++) {
                    for (let wy = 0; wy < 3; wy++) {
                        for (let wz = 0; wz < 3; wz++) {
                            const char = cube2[wx][wy][wz];
                            if (!map[char]) map[char] = {};
                            map[char].cube2 = { wx, wy, wz };
                        }
                    }
                }
                
                return map;
            }
            
            async shuffleAlphabet(alphabet, seed) {
                const encoder = new TextEncoder();
                const seedBuffer = encoder.encode(seed);
                const hashBuffer = await crypto.subtle.digest('SHA-256', seedBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                
                let shuffled = alphabet.split('');
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = hashArray[i % hashArray.length] % (i + 1);
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                
                return shuffled.join('');
            }
            
            fill3DCube(chars) {
                const cube = [];
                let pos = 0;
                
                for (let x = 0; x < 3; x++) {
                    cube[x] = [];
                    for (let y = 0; y < 3; y++) {
                        cube[x][y] = [];
                        for (let z = 0; z < 3; z++) {
                            cube[x][y][z] = chars[pos++ % chars.length];
                        }
                    }
                }
                
                return cube;
            }
            
            findCharCoordinates(char, hypercube) {
                const entry = hypercube.coordinateMap[char];
                if (!entry || !entry.cube1 || !entry.cube2) return null;
                
                return {
                    x: entry.cube1.x,
                    y: entry.cube1.y,
                    z: entry.cube1.z,
                    wx: entry.cube2.wx,
                    wy: entry.cube2.wy,
                    wz: entry.cube2.wz
                };
            }
            
            async process(text, rounds, isEncrypt) {
                let result = text.toUpperCase().replace(/[^A-Z0-9,.!?@#$%^&*()]/g, '');
                
                for (let round = 0; round < rounds; round++) {
                    const hypercube = this.hypercubes[round];
                    result = this.processRound(result, round, isEncrypt);
                }
                
                return result;
            }
            
            processRound(text, round, isEncrypt) {
                const hypercube = this.hypercubes[round];
                let result = '';
                
                if (isEncrypt) {
                    // Encryption
                    const allCoords = [];
                    
                    for (const char of text) {
                        const coords = this.findCharCoordinates(char, hypercube);
                        if (coords) {
                            allCoords.push(coords);
                        } else {
                            // Handle missing characters (use filler character)
                            allCoords.push({
                                x: 0, y: 0, z: 0,
                                wx: 0, wy: 0, wz: 0
                            });
                        }
                    }
                    
                    // Create coordinate streams
                    const streams = {
                        x: [], y: [], z: [],
                        wx: [], wy: [], wz: []
                    };
                    
                    allCoords.forEach(({x, y, z, wx, wy, wz}) => {
                        streams.x.push(x);
                        streams.y.push(y);
                        streams.z.push(z);
                        streams.wx.push(wx);
                        streams.wy.push(wy);
                        streams.wz.push(wz);
                    });
                    
                    // Combine streams: XWX YWY ZWZ
                    const fullStream = [
                        ...streams.x, ...streams.wx,
                        ...streams.y, ...streams.wy,
                        ...streams.z, ...streams.wz
                    ].join('');
                    
                    // Convert back to characters
                    for (let i = 0; i < fullStream.length; i += 3) {
                        const triplet = fullStream.substr(i, 3);
                        if (triplet.length === 3) {
                            const x = parseInt(triplet[0]);
                            const y = parseInt(triplet[1]);
                            const z = parseInt(triplet[2]);
                            result += hypercube.cube1[x][y][z] || this.fillerChar;
                        }
                    }
                } else {
                    // Decryption
                    const coordStream = [];
                    
                    // Convert text back to coordinate stream
                    for (const char of text) {
                        const coords = this.findCharCoordinates(char, hypercube);
                        if (coords) {
                            coordStream.push(
                                coords.x, coords.wx,
                                coords.y, coords.wy,
                                coords.z, coords.wz
                            );
                        } else {
                            // Handle missing characters
                            coordStream.push(0, 0, 0, 0, 0, 0);
                        }
                    }
                    
                    // Split into original coordinates
                    const mid = Math.floor(coordStream.length / 2);
                    const xCoords = coordStream.slice(0, mid);
                    const wxCoords = coordStream.slice(mid);
                    
                    // Reconstruct original characters
                    for (let i = 0; i < xCoords.length; i += 3) {
                        if (i + 2 >= xCoords.length) break;
                        
                        const x = xCoords[i];
                        const y = xCoords[i+1];
                        const z = xCoords[i+2];
                        
                        if (x !== undefined && y !== undefined && z !== undefined) {
                            result += hypercube.cube1[x][y][z] || this.fillerChar;
                        }
                    }
                }
                
                return result;
            }
            
            getCubeFaces(cube) {
                const faces = {
                    front: [], back: [],
                    right: [], left: [],
                    top: [], bottom: []
                };
                
                // Front face (z = 0)
                for (let x = 0; x < 3; x++) {
                    for (let y = 0; y < 3; y++) {
                        faces.front.push(cube[x][y][0]);
                    }
                }
                
                // Back face (z = 2)
                for (let x = 0; x < 3; x++) {
                    for (let y = 0; y < 3; y++) {
                        faces.back.push(cube[x][y][2]);
                    }
                }
                
                // Right face (x = 2)
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        faces.right.push(cube[2][y][z]);
                    }
                }
                
                // Left face (x = 0)
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        faces.left.push(cube[0][y][z]);
                    }
                }
                
                // Top face (y = 2)
                for (let x = 0; x < 3; x++) {
                    for (let z = 0; z < 3; z++) {
                        faces.top.push(cube[x][2][z]);
                    }
                }
                
                // Bottom face (y = 0)
                for (let x = 0; x < 3; x++) {
                    for (let z = 0; z < 3; z++) {
                        faces.bottom.push(cube[x][0][z]);
                    }
                }
                
                return faces;
            }
        }

        // UI Implementation
        document.addEventListener('DOMContentLoaded', () => {
            const cipher = new Trifid4D();
            let currentHypercube = null;
            
            // Tab switching
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.tab).classList.add('active');
                });
            });
            
            // Process button
            document.getElementById('processBtn').addEventListener('click', async () => {
                const inputText = document.getElementById('inputText').value;
                const key = document.getElementById('key').value;
                const rounds = parseInt(document.getElementById('rounds').value);
                const action = document.getElementById('action').value;
                
                if (!inputText) {
                    updateStatus('Please enter some text to process', 'error');
                    return;
                }
                
                if (!key) {
                    updateStatus('Please enter an encryption key', 'error');
                    return;
                }
                
                try {
                    updateStatus('Processing...');
                    
                    await cipher.init(key, rounds);
                    currentHypercube = cipher.hypercubes[0];
                    
                    const isEncrypt = action === 'encrypt';
                    const result = await cipher.process(inputText, rounds, isEncrypt);
                    
                    document.getElementById('outputText').value = result;
                    updateStatus(`${isEncrypt ? 'Encryption' : 'Decryption'} successful!`, 'success');
                    
                    // Update cube visualization
                    updateCubeVisualization();
                } catch (error) {
                    console.error('Error:', error);
                    updateStatus(`Error: ${error.message}`, 'error');
                }
            });
            
            // Clear button
            document.getElementById('clearBtn').addEventListener('click', () => {
                document.getElementById('inputText').value = '';
                document.getElementById('outputText').value = '';
                updateStatus('Cleared', 'success');
            });
            
            // Copy button
            document.getElementById('copyBtn').addEventListener('click', () => {
                const outputText = document.getElementById('outputText');
                outputText.select();
                document.execCommand('copy');
                updateStatus('Copied to clipboard!', 'success');
            });
            
            // Cube rotation controls
            document.getElementById('rotateXCube1').addEventListener('click', () => {
                rotateCube('cube1', 'x', 90);
            });
            
            document.getElementById('rotateYCube1').addEventListener('click', () => {
                rotateCube('cube1', 'y', 90);
            });
            
            document.getElementById('rotateZCube1').addEventListener('click', () => {
                rotateCube('cube1', 'z', 90);
            });
            
            document.getElementById('rotationSlider').addEventListener('input', (e) => {
                const angle = parseInt(e.target.value);
                document.getElementById('cube1').querySelector('.cube-inner').style.transform = 
                    `rotateX(${cipher.currentRotation.cube1.x}deg) rotateY(${angle}deg) rotateZ(${cipher.currentRotation.cube1.z}deg)`;
                document.getElementById('cube2').querySelector('.cube-inner').style.transform = 
                    `rotateX(${cipher.currentRotation.cube2.x}deg) rotateY(${angle}deg) rotateZ(${cipher.currentRotation.cube2.z}deg)`;
            });
            
            function updateStatus(message, type = '') {
                const statusElement = document.getElementById('status');
                statusElement.textContent = message;
                statusElement.className = 'status';
                if (type) statusElement.classList.add(type);
            }
            
            function updateCubeVisualization() {
                if (!currentHypercube) return;
                
                const cube1Faces = cipher.getCubeFaces(currentHypercube.cube1);
                const cube2Faces = cipher.getCubeFaces(currentHypercube.cube2);
                
                // Update cube1 faces
                Object.keys(cube1Faces).forEach(face => {
                    const faceElement = document.querySelector(`#cube1 .cube-face-${face}`);
                    faceElement.innerHTML = '';
                    
                    cube1Faces[face].forEach(char => {
                        const cell = document.createElement('div');
                        cell.className = 'cube-cell';
                        cell.textContent = char;
                        faceElement.appendChild(cell);
                    });
                });
                
                // Update cube2 faces
                Object.keys(cube2Faces).forEach(face => {
                    const faceElement = document.querySelector(`#cube2 .cube-face-${face}`);
                    faceElement.innerHTML = '';
                    
                    cube2Faces[face].forEach(char => {
                        const cell = document.createElement('div');
                        cell.className = 'cube-cell';
                        cell.textContent = char;
                        faceElement.appendChild(cell);
                    });
                });
                
                // Update cube state display
                document.getElementById('cubeState').textContent = 'Cubes initialized with current key';
            }
            
            function rotateCube(cubeId, axis, angle) {
                if (axis === 'x') cipher.currentRotation[cubeId].x += angle;
                if (axis === 'y') cipher.currentRotation[cubeId].y += angle;
                if (axis === 'z') cipher.currentRotation[cubeId].z += angle;
                
                const rotation = cipher.currentRotation[cubeId];
                document.getElementById(cubeId).querySelector('.cube-inner').style.transform = 
                    `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg) rotateZ(${rotation.z}deg)`;
            }
        });
    </script>
</body>
</html>
