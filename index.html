<!DOCTYPE html>
<html>
<head>
    <title>4D Trifid Cipher (Group Encryption)</title>
    <style>
        body { font-family: Arial; max-width: 800px; margin: 0 auto; padding: 20px; }
        textarea { width: 100%; height: 100px; margin-bottom: 10px; }
        button { padding: 8px 15px; margin-right: 10px; }
        .cube { display: inline-block; margin: 10px; vertical-align: top; }
        table { border-collapse: collapse; }
        td { width: 25px; height: 25px; border: 1px solid #000; text-align: center; font-size: 12px; }
        .highlight { background-color: yellow; }
    </style>
</head>
<body>
    <h2>4D Trifid Cipher (Group Encryption)</h2>
    
    <div>
        <textarea id="input" placeholder="Enter text"></textarea><br>
        <button onclick="encrypt()">Encrypt</button>
        <button onclick="decrypt()">Decrypt</button>
        <button onclick="clearAll()">Clear</button>
    </div>
    
    <div>
        <strong>Result:</strong>
        <div id="output"></div>
    </div>
    
    <div id="cubes"></div>

    <script>
        // Alphabet definition (4D cubes)
        const cubes = [
            [ // Latin (W=1)
                ['A','B','C','D','E','F','G','H','I'], // Z=1
                ['J','K','L','M','N','O','P','Q','R'], // Z=2
                ['S','T','U','V','W','X','Y','Z',' ']  // Z=3
            ],
            [ // Cyrillic (W=2)
                ['А','Б','В','Г','Д','Е','Ж','З','И'],
                ['Й','К','Л','М','Н','О','П','Р','С'],
                ['Т','У','Ф','Х','Ц','Ч','Ш','Щ','Ъ']
            ],
            [ // Symbols (W=3)
                ['1','2','3','4','5','6','7','8','9'],
                ['!','@','#','$','%','^','&','*','('],
                [')','-','+','=','/','?','|','~','§']
            ]
        ];

        // Group size (лучше 3-5 для Trifid-эффекта)
        const GROUP_SIZE = 5; 

        // Initialize cubes
        function initCubes() {
            let html = '';
            for (let w = 0; w < 3; w++) {
                html += `<div class="cube"><h3>Cube W=${w+1}</h3>`;
                for (let z = 0; z < 3; z++) {
                    html += `<div>Layer Z=${z+1}<table id="w${w+1}z${z+1}">`;
                    for (let y = 0; y < 3; y++) {
                        html += '<tr>';
                        for (let x = 0; x < 3; x++) {
                            const char = cubes[w][z][y*3 + x];
                            html += `<td onclick="showCoords(${x+1},${y+1},${z+1},${w+1})">${char}</td>`;
                        }
                        html += '</tr>';
                    }
                    html += '</table></div>';
                }
                html += '</div>';
            }
            document.getElementById('cubes').innerHTML = html;
        }

        // Find character coordinates
        function findChar(c) {
            for (let w = 0; w < 3; w++) {
                for (let z = 0; z < 3; z++) {
                    for (let y = 0; y < 3; y++) {
                        for (let x = 0; x < 3; x++) {
                            if (cubes[w][z][y*3 + x] === c) {
                                return { x: x+1, y: y+1, z: z+1, w: w+1 };
                            }
                        }
                    }
                }
            }
            return null;
        }

        // Get character from coordinates
        function getChar(x, y, z, w) {
            return cubes[w-1][z-1][(y-1)*3 + (x-1)] || '?';
        }

        // Encrypt a group of characters (Trifid-style)
        function encryptGroup(group) {
            let coords = [];
            
            // Step 1: Extract all coordinates
            for (const char of group) {
                const c = findChar(char);
                if (c) {
                    coords.push(c.x, c.y, c.z, c.w);
                } else {
                    coords.push(1, 1, 1, 1); // Fallback for unknown chars
                }
            }
            
            // Step 2: Permute coordinates (Trifid-style)
            // В классическом Trifid: (x,y,z) → (y,z,x)
            // Здесь: (x,y,z,w) → (y,w,x,z)
            const permuted = [];
            for (let i = 0; i < coords.length; i += 4) {
                const [x, y, z, w] = coords.slice(i, i+4);
                permuted.push(y, w, x, z);
            }
            
            // Step 3: Split into new 4D coordinates and get new chars
            let encrypted = '';
            for (let i = 0; i < permuted.length; i += 4) {
                const [x, y, z, w] = permuted.slice(i, i+4);
                encrypted += getChar(x, y, z, w);
            }
            
            return encrypted;
        }

        // Decrypt a group (reverse of encryption)
        function decryptGroup(group) {
            let coords = [];
            
            // Step 1: Extract all coordinates
            for (const char of group) {
                const c = findChar(char);
                if (c) {
                    coords.push(c.x, c.y, c.z, c.w);
                } else {
                    coords.push(1, 1, 1, 1);
                }
            }
            
            // Step 2: Reverse permutation (y,w,x,z) → (x,y,z,w)
            const reversed = [];
            for (let i = 0; i < coords.length; i += 4) {
                const [y, w, x, z] = coords.slice(i, i+4);
                reversed.push(x, y, z, w);
            }
            
            // Step 3: Get original chars
            let decrypted = '';
            for (let i = 0; i < reversed.length; i += 4) {
                const [x, y, z, w] = reversed.slice(i, i+4);
                decrypted += getChar(x, y, z, w);
            }
            
            return decrypted;
        }

        // Encrypt full text (split into groups)
        function encrypt() {
            const input = document.getElementById('input').value.toUpperCase();
            let output = '';
            
            // Pad input to multiple of GROUP_SIZE
            const padded = input + ' '.repeat((GROUP_SIZE - (input.length % GROUP_SIZE)) % GROUP_SIZE);
            
            // Process each group
            for (let i = 0; i < padded.length; i += GROUP_SIZE) {
                const group = padded.substr(i, GROUP_SIZE);
                output += encryptGroup(group);
            }
            
            document.getElementById('output').textContent = output;
        }

        // Decrypt full text
        function decrypt() {
            const input = document.getElementById('input').value;
            let output = '';
            
            for (let i = 0; i < input.length; i += GROUP_SIZE) {
                const group = input.substr(i, GROUP_SIZE);
                output += decryptGroup(group);
            }
            
            document.getElementById('output').textContent = output.trim();
        }

        // Clear all
        function clearAll() {
            document.getElementById('input').value = '';
            document.getElementById('output').textContent = '';
        }

        // Show coordinates
        function showCoords(x, y, z, w) {
            alert(`Char: ${getChar(x,y,z,w)}\nCoords: (${x},${y},${z},${w})`);
        }

        // Initialize
        window.onload = initCubes;
    </script>
</body>
</html>
