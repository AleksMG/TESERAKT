<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D HyperCipher Pro - Усовершенствованный 4D шифр</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        :root {
            --primary: #4361ee;
            --primary-dark: #3a56d4;
            --secondary: #3f37c9;
            --accent: #4895ef;
            --light: #f8f9fa;
            --dark: #212529;
            --gray: #6c757d;
            --light-gray: #e9ecef;
            --success: #4cc9f0;
            --error: #f72585;
            --warning: #f8961e;
            --border-radius: 8px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
            --card-bg: rgba(255, 255, 255, 0.95);
            --input-bg: rgba(255, 255, 255, 0.9);
        }

        [data-theme="dark"] {
            --light: #121212;
            --dark: #f8f9fa;
            --gray: #adb5bd;
            --light-gray: #343a40;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            --card-bg: rgba(30, 30, 40, 0.95);
            --input-bg: rgba(40, 40, 50, 0.9);
            --primary: #4895ef;
            --primary-dark: #3f84d6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Roboto', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: var(--dark);
            background-color: var(--light);
            min-height: 100vh;
            padding: 2rem;
            transition: var(--transition);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        h1, h2, h3, h4 {
            color: var(--primary);
            margin-bottom: 1rem;
            font-weight: 600;
        }

        h1 {
            font-size: 2rem;
        }

        h2 {
            font-size: 1.75rem;
        }

        h3 {
            font-size: 1.5rem;
        }

        h4 {
            font-size: 1.25rem;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        [data-theme="dark"] .card {
            border-color: rgba(255, 255, 255, 0.05);
        }

        .card:hover {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--light-gray);
            padding-bottom: 0.5rem;
            flex-wrap: wrap;
        }

        .tab {
            padding: 0.75rem 1.25rem;
            background-color: rgba(0, 0, 0, 0.05);
            cursor: pointer;
            border-radius: var(--border-radius) var(--border-radius) 0 0;
            transition: var(--transition);
            font-weight: 500;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        [data-theme="dark"] .tab {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .tab:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] .tab:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .tab.active {
            background-color: var(--primary);
            color: white;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.25rem;
            margin: 1.25rem 0;
        }

        .hypercube-container {
            display: flex;
            gap: 1.5rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .hypercube-view {
            flex: 1;
            min-width: 400px;
            height: 400px;
            background: var(--input-bg);
            border-radius: var(--border-radius);
            position: relative;
            overflow: hidden;
        }

        .form-group {
            margin-bottom: 1.25rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--dark);
            font-size: 0.95rem;
        }

        textarea, input[type="text"], input[type="number"], input[type="password"], select {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--light-gray);
            border-radius: var(--border-radius);
            font-family: 'Courier New', monospace;
            transition: var(--transition);
            background-color: var(--input-bg);
            color: var(--dark);
            font-size: 0.95rem;
        }

        textarea {
            min-height: 120px;
            resize: vertical;
        }

        textarea:focus, 
        input[type="text"]:focus,
        input[type="number"]:focus,
        input[type="password"]:focus,
        select:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 0.2rem rgba(67, 97, 238, 0.25);
            outline: none;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 500;
            transition: var(--transition);
            font-size: 0.95rem;
            white-space: nowrap;
        }

        .btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
        }

        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
        }

        .btn-outline:hover {
            background-color: var(--primary);
            color: white;
        }

        .btn-danger {
            background-color: var(--error);
        }

        .btn-danger:hover {
            background-color: #d1145a;
        }

        .btn-warning {
            background-color: var(--warning);
            color: var(--dark);
        }

        .btn-warning:hover {
            background-color: #e07d10;
        }

        .btn-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            margin-bottom: 1.25rem;
        }

        .alert {
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-bottom: 1.25rem;
            border-left: 4px solid transparent;
            font-size: 0.95rem;
        }

        .alert-success {
            background-color: rgba(76, 201, 240, 0.15);
            border-left-color: var(--success);
        }

        .alert-error {
            background-color: rgba(247, 37, 133, 0.15);
            border-left-color: var(--error);
        }

        .alert-warning {
            background-color: rgba(248, 150, 30, 0.15);
            border-left-color: var(--warning);
        }

        .process-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 0.9rem;
        }

        .process-table th, .process-table td {
            border: 1px solid var(--light-gray);
            padding: 0.75rem;
            text-align: left;
        }

        .process-table th {
            background-color: var(--primary);
            color: white;
            font-weight: 600;
        }

        .process-table tr:nth-child(even) {
            background-color: rgba(0, 0, 0, 0.03);
        }

        [data-theme="dark"] .process-table tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .theme-toggle {
            background: none;
            border: none;
            font-size: 1.25rem;
            cursor: pointer;
            color: var(--dark);
            transition: var(--transition);
            padding: 0.5rem;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .theme-toggle:hover {
            background-color: rgba(0, 0, 0, 0.05);
            transform: rotate(30deg);
        }

        [data-theme="dark"] .theme-toggle:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .settings-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .settings-group {
            flex: 1;
            min-width: 280px;
            background-color: rgba(0, 0, 0, 0.03);
            padding: 1rem;
            border-radius: var(--border-radius);
            border: 1px solid var(--light-gray);
        }

        [data-theme="dark"] .settings-group {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .settings-group h4 {
            margin-bottom: 0.75rem;
        }

        .error {
            color: var(--error);
            font-weight: bold;
        }

        .success {
            color: var(--success);
            font-weight: bold;
        }

        .warning {
            color: var(--warning);
            font-weight: bold;
        }

        .char-highlight {
            background-color: rgba(67, 97, 238, 0.2);
            padding: 0.1rem 0.25rem;
            border-radius: 0.25rem;
            font-family: 'Courier New', monospace;
        }

        .char-skipped {
            background-color: rgba(248, 150, 30, 0.2);
            padding: 0.1rem 0.25rem;
            border-radius: 0.25rem;
            font-family: 'Courier New', monospace;
        }

        .settings-file-input {
            display: none;
        }

        .settings-file-label {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background-color: rgba(67, 97, 238, 0.1);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.95rem;
        }

        .settings-file-label:hover {
            background-color: rgba(67, 97, 238, 0.2);
        }

        .readonly-field {
            background-color: rgba(0, 0, 0, 0.05) !important;
            cursor: not-allowed;
        }

        [data-theme="dark"] .readonly-field {
            background-color: rgba(255, 255, 255, 0.05) !important;
        }

        .round-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background-color: var(--primary);
            color: white;
            border-radius: 50%;
            font-size: 0.8rem;
            margin-right: 0.5rem;
            font-weight: bold;
        }

        .security-meter {
            height: 8px;
            background-color: var(--light-gray);
            border-radius: 4px;
            margin-top: 0.5rem;
            overflow: hidden;
        }

        .security-meter-fill {
            height: 100%;
            background-color: var(--success);
            width: 0%;
            transition: width 0.5s ease;
        }

        .password-strength {
            display: flex;
            justify-content: space-between;
            margin-top: 0.25rem;
            font-size: 0.8rem;
            color: var(--gray);
        }

        .password-strength span {
            transition: color 0.3s ease;
        }

        .password-strength .active {
            color: var(--success);
            font-weight: bold;
        }

        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: var(--dark);
            color: var(--light);
            text-align: center;
            border-radius: var(--border-radius);
            padding: 0.75rem;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            font-weight: normal;
            box-shadow: var(--box-shadow);
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .status-icon {
            margin-right: 0.5rem;
        }

        .text-preview {
            font-family: 'Courier New', monospace;
            line-height: 1.8;
            word-break: break-all;
            padding: 0.5rem;
            background-color: var(--input-bg);
            border-radius: var(--border-radius);
            border: 1px solid var(--light-gray);
        }

        .copy-feedback {
            display: inline-block;
            margin-left: 0.5rem;
            color: var(--success);
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .copy-feedback.show {
            opacity: 1;
        }

        .hypercube-title {
            font-size: 1rem;
            font-weight: bold;
            margin-bottom: 0.75rem;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .hypercube-controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .hypercube-dimension {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .symbol-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .symbol-table th, .symbol-table td {
            border: 1px solid var(--light-gray);
            padding: 0.5rem;
            text-align: center;
        }

        .symbol-table th {
            background-color: var(--primary);
            color: white;
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            
            .grid-container {
                grid-template-columns: 1fr;
            }
            
            .btn-group {
                gap: 0.5rem;
            }
            
            .settings-row {
                flex-direction: column;
                gap: 1rem;
            }
            
            .card {
                padding: 1rem;
            }
            
            .hypercube-view {
                min-width: 100%;
                height: 300px;
            }
            
            h1 {
                font-size: 1.75rem;
            }
        }

        @media (max-width: 480px) {
            .tabs {
                overflow-x: auto;
                padding-bottom: 0.5rem;
                flex-wrap: nowrap;
                -webkit-overflow-scrolling: touch;
            }
            
            .tab {
                padding: 0.5rem 0.75rem;
                font-size: 0.85rem;
            }
            
            .btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.85rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-cube"></i> 4D HyperCipher Pro</h1>
            <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
                <i class="fas fa-moon"></i>
            </button>
        </header>

        <div class="card">
            <div class="tabs">
                <div class="tab active" data-tab="settings"><i class="fas fa-cog"></i> Настройки</div>
                <div class="tab" data-tab="encrypt"><i class="fas fa-lock"></i> Шифрование</div>
                <div class="tab" data-tab="decrypt"><i class="fas fa-lock-open"></i> Дешифрование</div>
                <div class="tab" data-tab="about"><i class="fas fa-info-circle"></i> О шифре</div>
            </div>

            <div id="settings" class="tab-content active">
                <h2><i class="fas fa-sliders-h"></i> Конфигурация 4D-шифра</h2>
                
                <div class="settings-row">
                    <div class="settings-group">
                        <h4><i class="fas fa-font"></i> Параметры алфавита</h4>
                        <div class="form-group">
                            <label for="alphabet">Алфавит (54 уникальных символа)</label>
                            <textarea id="alphabet" rows="3">ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_-+=[]{};:,.<>?</textarea>
                        </div>
                        
                        <div class="form-group">
                            <label for="filler">Заполняющий символ (не должен быть в алфавите)</label>
                            <input type="text" id="filler" value="~" maxlength="1">
                        </div>
                    </div>
                    
                    <div class="settings-group">
                        <h4><i class="fas fa-key"></i> Параметры безопасности</h4>
                        <div class="form-group">
                            <label for="encryptionKey">
                                Ключ шифрования
                                <span class="tooltip">
                                    <i class="fas fa-question-circle"></i>
                                    <span class="tooltiptext">Используйте сложную парольную фразу минимум из 12 символов</span>
                                </span>
                            </label>
                            <input type="password" id="encryptionKey" placeholder="Введите ключ шифрования">
                            <div class="security-meter">
                                <div class="security-meter-fill" id="securityMeter"></div>
                            </div>
                            <div class="password-strength" id="passwordStrength">
                                <span data-level="1">Слабый</span>
                                <span data-level="2">Средний</span>
                                <span data-level="3">Сильный</span>
                                <span data-level="4">Очень сильный</span>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="rounds">Количество раундов (3-10)</label>
                            <input type="number" id="rounds" min="3" max="10" value="5">
                        </div>
                    </div>
                </div>
                
                <div class="btn-group">
                    <button class="btn" id="initCubes"><i class="fas fa-cube"></i> Инициализировать гиперкубы</button>
                    <button class="btn btn-outline" id="resetCubes"><i class="fas fa-undo"></i> Сбросить настройки</button>
                    <button class="btn btn-outline" id="advancedSettings"><i class="fas fa-cogs"></i> Расширенные настройки</button>
                </div>
                
                <div id="alphabetStatus" class="alert" style="display: none;"></div>
                
                <div id="hypercubesVisualization">
                    <h3><i class="fas fa-project-diagram"></i> 4D Гиперкубы</h3>
                    <div class="hypercube-container">
                        <div class="hypercube-view" id="hypercube1-display">
                            <div class="hypercube-dimension">3D проекция: XYZ</div>
                        </div>
                        <div class="hypercube-view" id="hypercube2-display">
                            <div class="hypercube-dimension">3D проекция: WXWYWZ</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="encrypt" class="tab-content">
                <h2><i class="fas fa-lock"></i> Шифрование сообщения</h2>
                
                <div class="form-group">
                    <label for="plaintext"><i class="fas fa-pen"></i> Исходный текст</label>
                    <textarea id="plaintext" placeholder="Введите текст для шифрования"></textarea>
                    <div class="text-preview" id="plaintextPreview"></div>
                </div>
                
                <div class="btn-group">
                    <button class="btn" id="encryptBtn"><i class="fas fa-key"></i> Зашифровать</button>
                    <button class="btn btn-outline" id="clearPlaintext"><i class="fas fa-trash"></i> Очистить</button>
                    <button class="btn btn-outline" id="samplePlaintext"><i class="fas fa-lightbulb"></i> Пример текста</button>
                </div>
                
                <div id="encryptionResult" class="alert alert-success" style="display: none;">
                    <h3><i class="fas fa-check-circle"></i> Шифрование успешно</h3>
                    <p><strong>Шифротекст:</strong></p>
                    <div class="text-preview" id="ciphertextOutput"></div>
                    <button class="btn btn-outline" id="copyCiphertext"><i class="fas fa-copy"></i> Копировать</button>
                    <span class="copy-feedback" id="cipherCopyFeedback">Скопировано!</span>
                </div>
                
                <div id="encryptionSteps" class="visualization"></div>
            </div>

            <div id="decrypt" class="tab-content">
                <h2><i class="fas fa-lock-open"></i> Дешифрование сообщения</h2>
                
                <div class="form-group">
                    <label for="ciphertext"><i class="fas fa-pen"></i> Шифротекст</label>
                    <textarea id="ciphertext" placeholder="Введите текст для дешифрования"></textarea>
                    <div class="text-preview" id="ciphertextPreview"></div>
                </div>
                
                <div class="btn-group">
                    <button class="btn" id="decryptBtn"><i class="fas fa-key"></i> Дешифровать</button>
                    <button class="btn btn-outline" id="clearCiphertext"><i class="fas fa-trash"></i> Очистить</button>
                    <button class="btn btn-outline" id="sampleCiphertext"><i class="fas fa-lightbulb"></i> Пример шифротекста</button>
                </div>
                
                <div id="decryptionResult" class="alert alert-success" style="display: none;">
                    <h3><i class="fas fa-check-circle"></i> Дешифрование успешно</h3>
                    <p><strong>Исходный текст:</strong></p>
                    <div class="text-preview" id="plaintextOutput"></div>
                    <button class="btn btn-outline" id="copyPlaintext"><i class="fas fa-copy"></i> Копировать</button>
                    <span class="copy-feedback" id="plainCopyFeedback">Скопировано!</span>
                </div>
                
                <div id="decryptionSteps" class="visualization"></div>
            </div>

            <div id="about" class="tab-content">
                <h2><i class="fas fa-info-circle"></i> О 4D HyperCipher Pro</h2>
                
                <div class="card">
                    <h3><i class="fas fa-question-circle"></i> Криптографические принципы</h3>
                    <p>Это улучшенная реализация 4D-шифра, объединяющая концепции Trifid Cipher с 4-мерным гиперкубом для повышенной безопасности:</p>
                    
                    <h4><i class="fas fa-shield-alt"></i> Улучшения безопасности:</h4>
                    <ul>
                        <li><strong>4D координаты:</strong> Каждый символ кодируется координатами в двух 3D кубах (XYZ и WXWYWZ)</li>
                        <li><strong>Многократное шифрование:</strong> Конфигурируемое количество раундов (3-10) с разными кубами для каждого раунда</li>
                        <li><strong>Криптографически стойкая генерация кубов:</strong> Использует PBKDF2 с SHA-256 для растяжения ключа (100,000 итераций)</li>
                        <li><strong>Диффузия:</strong> Каждый раунд полностью преобразует данные с использованием разных кубов</li>
                        <li><strong>Запутывание:</strong> Сложная зависимость между ключом и шифротекстом</li>
                    </ul>
                    
                    <h4><i class="fas fa-key"></i> Процесс генерации гиперкубов:</h4>
                    <ol>
                        <li>Создание основного seed из ключа шифрования с использованием PBKDF2</li>
                        <li>Для каждого раунда:
                            <ul>
                                <li>Генерация раундового seed с использованием HMAC-SHA256</li>
                                <li>Перемешивание алфавита с использованием криптографически стойкого алгоритма Fisher-Yates</li>
                                <li>Заполнение двух 3×3×3 кубов (XYZ и WXWYWZ) перемешанными символами</li>
                            </ul>
                        </li>
                        <li>Проверка уникальности всех кубов и корректности заполнения</li>
                    </ol>

                    <h4><i class="fas fa-user-secret"></i> Рекомендации по безопасности:</h4>
                    <ul>
                        <li>Используйте сложную парольную фразу минимум из 12 символов</li>
                        <li>Включайте заглавные и строчные буквы, цифры и специальные символы в ключ</li>
                        <li>Используйте минимум 5 раундов шифрования для важных данных</li>
                        <li>Никогда не используйте один и тот же ключ для разных целей</li>
                        <li>Рассмотрите комбинацию с другими методами шифрования для максимальной безопасности</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        class HyperCipher4D {
            constructor() {
                this.hypercubes = [];
                this.alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_-+=[]{};:,.<>?";
                this.fillerChar = "~";
                this.encryptionKey = "";
                this.rounds = 5;
                this.salt = CryptoJS.lib.WordArray.random(16).toString();
                this.fillMethod = "row";
                this.scenes = [];
                this.renderers = [];
                this.cameras = [];
                this.symbolElements = [];
                this.initEventListeners();
                this.initTheme();
                this.setupTextPreviews();
                this.setupPasswordStrengthMeter();
            }

            // ========================
            // Initialization Methods
            // ========================

            initEventListeners() {
                // Tab switching
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
                });

                // Core functionality
                document.getElementById('initCubes').addEventListener('click', () => this.initHypercubes());
                document.getElementById('resetCubes').addEventListener('click', () => this.resetToDefault());
                document.getElementById('encryptBtn').addEventListener('click', () => this.encrypt());
                document.getElementById('decryptBtn').addEventListener('click', () => this.decrypt());
                
                // Text management
                document.getElementById('clearPlaintext').addEventListener('click', () => {
                    document.getElementById('plaintext').value = '';
                    document.getElementById('plaintextPreview').textContent = '';
                });
                document.getElementById('clearCiphertext').addEventListener('click', () => {
                    document.getElementById('ciphertext').value = '';
                    document.getElementById('ciphertextPreview').textContent = '';
                });
                
                // Samples and copying
                document.getElementById('samplePlaintext').addEventListener('click', () => this.loadSampleText('plain'));
                document.getElementById('sampleCiphertext').addEventListener('click', () => this.loadSampleText('cipher'));
                document.getElementById('copyCiphertext').addEventListener('click', () => this.copyToClipboard('ciphertextOutput', 'cipherCopyFeedback'));
                document.getElementById('copyPlaintext').addEventListener('click', () => this.copyToClipboard('plaintextOutput', 'plainCopyFeedback'));
                
                // Settings management
                document.getElementById('themeToggle').addEventListener('click', () => this.toggleTheme());
                document.getElementById('advancedSettings').addEventListener('click', () => this.showAdvancedSettings());
                
                // Dynamic updates
                document.getElementById('encryptionKey').addEventListener('input', (e) => {
                    this.encryptionKey = e.target.value;
                    this.updatePasswordStrength(e.target.value);
                });
                document.getElementById('rounds').addEventListener('change', (e) => {
                    this.rounds = Math.min(10, Math.max(3, parseInt(e.target.value)));
                });
            }

            setupTextPreviews() {
                document.getElementById('plaintext').addEventListener('input', (e) => {
                    this.updateTextPreview(e.target.value, 'plaintextPreview');
                });
                document.getElementById('ciphertext').addEventListener('input', (e) => {
                    this.updateTextPreview(e.target.value, 'ciphertextPreview');
                });
            }

            setupPasswordStrengthMeter() {
                document.getElementById('encryptionKey').addEventListener('input', (e) => {
                    this.updatePasswordStrength(e.target.value);
                });
            }

            initTheme() {
                const savedTheme = localStorage.getItem('theme') || 'light';
                document.body.setAttribute('data-theme', savedTheme);
                this.updateThemeIcon(savedTheme);
            }

            // ========================
            // Core Cipher Methods
            // ========================

            async initHypercubes() {
                const alphabetInput = document.getElementById('alphabet').value;
                const newFiller = document.getElementById('filler').value.trim();
                const statusElement = document.getElementById('alphabetStatus');

                // Validate alphabet
                if (alphabetInput.length !== 54) {
                    this.showError(statusElement, `Алфавит должен содержать ровно 54 символа (сейчас: ${alphabetInput.length})`);
                    return false;
                }

                const uniqueChars = new Set(alphabetInput);
                if (uniqueChars.size !== alphabetInput.length) {
                    this.showError(statusElement, "Алфавит содержит повторяющиеся символы");
                    return false;
                }

                // Validate filler
                if (newFiller.length !== 1) {
                    this.showError(statusElement, "Заполняющий символ должен быть ровно 1 символ");
                    return false;
                }

                if (alphabetInput.includes(newFiller)) {
                    this.showError(statusElement, "Заполняющий символ не должен быть в алфавите");
                    return false;
                }

                // Store validated values
                this.alphabet = alphabetInput;
                this.fillerChar = newFiller;
                this.encryptionKey = document.getElementById('encryptionKey').value;
                this.rounds = parseInt(document.getElementById('rounds').value);

                try {
                    // Generate hypercubes for all rounds
                    await this.generateAllHypercubes();

                    // Update previews
                    this.updateTextPreview(document.getElementById('plaintext').value, 'plaintextPreview');
                    this.updateTextPreview(document.getElementById('ciphertext').value, 'ciphertextPreview');

                    // Show success
                    this.showSuccess(statusElement, `Успешно сгенерировано ${this.rounds} раундов 4D-шифрования`);
                    
                    // Visualize hypercubes
                    this.visualizeHypercubes();

                    return true;
                } catch (error) {
                    this.showError(statusElement, `Ошибка при генерации гиперкубов: ${error.message}`);
                    console.error("Hypercube generation error:", error);
                    return false;
                }
            }

            async generateAllHypercubes() {
                this.hypercubes = [];
                const key = this.encryptionKey;
                
                try {
                    if (!key) {
                        // Without key - use alphabetical order
                        if (!confirm("Внимание: Ключ шифрования не указан. Используется алфавитный порядок, который НЕ ОБЕСПЕЧИВАЕТ БЕЗОПАСНОСТЬ. Продолжить?")) {
                            throw new Error("Генерация гиперкубов отменена");
                        }
                        const hypercube = this.generateAlphabeticalHypercube();
                        for (let round = 0; round < this.rounds; round++) {
                            this.hypercubes.push(JSON.parse(JSON.stringify(hypercube))); // Deep copy
                        }
                    } else {
                        // With key - deterministic generation
                        const masterSeed = await this.deriveKey(key, this.salt, 100000);
                        
                        for (let round = 0; round < this.rounds; round++) {
                            const roundSeed = await this.hmacSha256(masterSeed, round.toString());
                            const hypercube = await this.generateHypercubeFromSeed(roundSeed);
                            this.hypercubes.push(hypercube);
                        }
                    }
                    
                    this.verifyHypercubeUniqueness();
                } catch (error) {
                    console.error("Error in hypercube generation:", error);
                    throw error;
                }
            }

            generateAlphabeticalHypercube() {
                const hypercube = {
                    cube1: [], // XYZ cube
                    cube2: []  // WXWYWZ cube
                };
                
                let pos = 0;
                
                // Fill XYZ cube (3x3x3)
                for (let x = 0; x < 3; x++) {
                    hypercube.cube1[x] = [];
                    for (let y = 0; y < 3; y++) {
                        hypercube.cube1[x][y] = [];
                        for (let z = 0; z < 3; z++) {
                            hypercube.cube1[x][y][z] = this.alphabet[pos++ % this.alphabet.length];
                        }
                    }
                }
                
                // Fill WXWYWZ cube (3x3x3)
                for (let wx = 0; wx < 3; wx++) {
                    hypercube.cube2[wx] = [];
                    for (let wy = 0; wy < 3; wy++) {
                        hypercube.cube2[wx][wy] = [];
                        for (let wz = 0; wz < 3; wz++) {
                            hypercube.cube2[wx][wy][wz] = this.alphabet[pos++ % this.alphabet.length];
                        }
                    }
                }
                
                return hypercube;
            }

            async generateHypercubeFromSeed(seed) {
                const shuffledAlphabet = await this.deterministicShuffle(this.alphabet, seed);
                
                const hypercube = {
                    cube1: this.fill3DCube(shuffledAlphabet, 0, 27),
                    cube2: this.fill3DCube(shuffledAlphabet, 27, 27)
                };
                
                return hypercube;
            }

            fill3DCube(alphabet, startIndex, count) {
                const cube = [];
                let pos = 0;
                
                for (let x = 0; x < 3; x++) {
                    cube[x] = [];
                    for (let y = 0; y < 3; y++) {
                        cube[x][y] = [];
                        for (let z = 0; z < 3; z++) {
                            if (startIndex + pos < alphabet.length) {
                                cube[x][y][z] = alphabet[startIndex + pos];
                            } else {
                                // Wrap around if alphabet is smaller than cube size
                                cube[x][y][z] = alphabet[(startIndex + pos) % alphabet.length];
                            }
                            pos++;
                        }
                    }
                }
                
                return cube;
            }

            // ========================
            // Cryptographic Helpers
            // ========================

            async deterministicShuffle(array, seedString) {
                // Use CryptoJS for consistent hashing
                const seed = CryptoJS.SHA256(seedString).toString();
                
                // Convert hex hash to number array
                const hashArray = [];
                for (let i = 0; i < seed.length; i += 2) {
                    hashArray.push(parseInt(seed.substr(i, 2), 16));
                }
                
                // Fisher-Yates with deterministic selection
                const arr = array.split('');
                let hashIndex = 0;
                
                for (let i = arr.length - 1; i > 0; i--) {
                    // Get bytes from hash cyclically
                    const randomByte = hashArray[hashIndex % hashArray.length];
                    hashIndex++;
                    
                    // Calculate swap index
                    const j = randomByte % (i + 1);
                    
                    // Swap
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                
                return arr.join('');
            }

            async deriveKey(password, salt, iterations) {
                // Use CryptoJS implementation of PBKDF2
                const key = CryptoJS.PBKDF2(password, salt, {
                    keySize: 256/32,
                    iterations: iterations,
                    hasher: CryptoJS.algo.SHA256
                });
                
                return key.toString();
            }

            async hmacSha256(key, message) {
                return CryptoJS.HmacSHA256(message, key).toString();
            }

            verifyHypercubeUniqueness() {
                const cubeHashes = new Set();
                
                for (const hypercube of this.hypercubes) {
                    const cubeString = JSON.stringify(hypercube);
                    const cubeHash = this.hashString(cubeString);
                    
                    if (cubeHashes.has(cubeHash)) {
                        throw new Error("Обнаружен дубликат гиперкуба - увеличьте сложность ключа или количество раундов");
                    }
                    cubeHashes.add(cubeHash);
                }
            }

            hashString(str) {
                return CryptoJS.SHA256(str).toString();
            }

            // ========================
            // Encryption/Decryption
            // ========================

            async encrypt() {
                const plaintext = document.getElementById('plaintext').value;
                if (!plaintext) {
                    alert("Пожалуйста, введите текст для шифрования");
                    return;
                }

                if (this.hypercubes.length === 0) {
                    alert("Пожалуйста, сначала инициализируйте гиперкубы");
                    return;
                }

                try {
                    let intermediate = plaintext;
                    let stepsHTML = '<div class="card"><h3><i class="fas fa-sync-alt"></i> Процесс многократного шифрования</h3>';
                    stepsHTML += `<p>Используется ${this.rounds} раундов шифрования с ключевыми гиперкубами</p>`;

                    for (let round = 0; round < this.rounds; round++) {
                        stepsHTML += `<div class="card"><h4><span class="round-badge">${round+1}</span> Раунд шифрования ${round+1}/${this.rounds}</h4>`;
                        
                        const roundResult = this.singleRoundEncrypt(intermediate, round);
                        intermediate = roundResult.ciphertext;
                        
                        stepsHTML += roundResult.steps;
                        stepsHTML += `<p><strong>Результат раунда ${round+1}:</strong> <code>${this.escapeHtml(intermediate)}</code></p>`;
                        stepsHTML += '</div>';
                    }

                    stepsHTML += '</div>';

                    document.getElementById('encryptionResult').style.display = 'block';
                    document.getElementById('ciphertextOutput').textContent = intermediate;
                    document.getElementById('encryptionSteps').innerHTML = stepsHTML;
                    this.updateTextPreview(intermediate, 'ciphertextPreview');
                } catch (error) {
                    console.error("Ошибка шифрования:", error);
                    alert(`Ошибка шифрования: ${error.message}`);
                }
            }

            singleRoundEncrypt(text, round) {
                let stepsHTML = '';
                let coordinates = [];
                let skippedChars = [];
                
                // Generate coordinate table
                let coordTable = `
                    <table class="process-table">
                        <thead>
                            <tr>
                                <th>Символ</th>
                                <th>XYZ (x,y,z)</th>
                                <th>WXWYWZ (wx,wy,wz)</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                // Find coordinates for each character
                for (let char of text) {
                    const coords = this.find4DCoordinates(char, round);
                    if (coords) {
                        coordinates.push(coords);
                        coordTable += `
                            <tr>
                                <td><code>${this.escapeHtml(char)}</code></td>
                                <td>${coords.xyz.join(',')}</td>
                                <td>${coords.wxwywz.join(',')}</td>
                            </tr>
                        `;
                    } else {
                        skippedChars.push(char);
                        coordTable += `
                            <tr>
                                <td><code>${this.escapeHtml(char)}</code></td>
                                <td colspan="2" class="error">(Не найден в гиперкубах - сохранен)</td>
                            </tr>
                        `;
                    }
                }
                coordTable += `</tbody></table>`;
                stepsHTML += coordTable;

                // Handle case where no characters are in hypercubes
                if (coordinates.length === 0) {
                    return {
                        ciphertext: text,
                        steps: stepsHTML + `<p class="warning">Ни один символ не найден в гиперкубах. Шифрование не выполнено.</p>`
                    };
                }

                // Create coordinate streams
                let xyzStream = coordinates.map(c => c.xyz.join('')).join('');
                let wxwywzStream = coordinates.map(c => c.wxwywz.join('')).join('');
                let combinedStream = xyzStream + wxwywzStream;

                stepsHTML += `
                    <p><strong>Поток координат XYZ:</strong> <code>${this.chunkString(xyzStream, 5)}</code></p>
                    <p><strong>Поток координат WXWYWZ:</strong> <code>${this.chunkString(wxwywzStream, 5)}</code></p>
                    <p><strong>Объединенный поток:</strong> <code>${this.chunkString(combinedStream, 5)}</code></p>
                `;

                // Generate ciphertext from triplets
                let ciphertext = '';
                let tripletTable = `
                    <table class="process-table">
                        <thead>
                            <tr>
                                <th>Триплет</th>
                                <th>XYZ (x,y,z)</th>
                                <th>WXWYWZ (wx,wy,wz)</th>
                                <th>Символ</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                for (let i = 0; i < combinedStream.length; i += 6) {
                    let triplet = combinedStream.substr(i, 6);
                    if (triplet.length === 6) {
                        const x = parseInt(triplet[0]);
                        const y = parseInt(triplet[1]);
                        const z = parseInt(triplet[2]);
                        const wx = parseInt(triplet[3]);
                        const wy = parseInt(triplet[4]);
                        const wz = parseInt(triplet[5]);
                        
                        // Get character from XYZ cube
                        const char = this.getCharFrom4DCoordinates(x, y, z, wx, wy, wz, round);
                        ciphertext += char;
                        
                        tripletTable += `
                            <tr>
                                <td><code>${triplet}</code></td>
                                <td>${x},${y},${z}</td>
                                <td>${wx},${wy},${wz}</td>
                                <td><code>${this.escapeHtml(char)}</code></td>
                            </tr>
                        `;
                    } else {
                        ciphertext += this.fillerChar;
                        tripletTable += `
                            <tr>
                                <td><code>${triplet}</code></td>
                                <td colspan="3" class="error">(Неполный триплет - использован заполняющий символ)</td>
                            </tr>
                        `;
                    }
                }
                tripletTable += `</tbody></table>`;
                stepsHTML += tripletTable;

                // Reinsert skipped characters if any
                if (skippedChars.length > 0) {
                    let originalIndex = 0;
                    let cipherIndex = 0;
                    let finalCiphertext = '';
                    
                    for (let char of text) {
                        const coords = this.find4DCoordinates(char, round);
                        if (coords) {
                            if (cipherIndex < ciphertext.length) {
                                finalCiphertext += ciphertext[cipherIndex++];
                            } else {
                                finalCiphertext += this.fillerChar;
                            }
                        } else {
                            finalCiphertext += char;
                        }
                    }
                    
                    if (cipherIndex < ciphertext.length) {
                        finalCiphertext += ciphertext.substring(cipherIndex);
                    }
                    
                    ciphertext = finalCiphertext;
                    
                    stepsHTML += `<p><i class="fas fa-exchange-alt"></i> Восстановлено ${skippedChars.length} сохраненных символов в исходных позициях</p>`;
                }

                return {
                    ciphertext: ciphertext,
                    steps: stepsHTML
                };
            }

            async decrypt() {
                const ciphertext = document.getElementById('ciphertext').value;
                if (!ciphertext) {
                    alert("Пожалуйста, введите текст для дешифрования");
                    return;
                }

                if (this.hypercubes.length === 0) {
                    alert("Пожалуйста, сначала инициализируйте гиперкубы");
                    return;
                }

                try {
                    let intermediate = ciphertext;
                    let stepsHTML = '<div class="card"><h3><i class="fas fa-sync-alt"></i> Процесс многократного дешифрования</h3>';
                    stepsHTML += `<p>Используется ${this.rounds} раундов дешифрования с ключевыми гиперкубами</p>`;

                    // Perform decryption in reverse round order
                    for (let round = this.rounds - 1; round >= 0; round--) {
                        stepsHTML += `<div class="card"><h4><span class="round-badge">${this.rounds-round}</span> Раунд дешифрования ${this.rounds-round}/${this.rounds}</h4>`;
                        
                        const roundResult = this.singleRoundDecrypt(intermediate, round);
                        intermediate = roundResult.plaintext;
                        
                        stepsHTML += roundResult.steps;
                        stepsHTML += `<p><strong>Результат раунда ${this.rounds-round}:</strong> <code>${this.escapeHtml(intermediate)}</code></p>`;
                        stepsHTML += '</div>';
                    }

                    stepsHTML += '</div>';

                    document.getElementById('decryptionResult').style.display = 'block';
                    document.getElementById('plaintextOutput').textContent = intermediate;
                    document.getElementById('decryptionSteps').innerHTML = stepsHTML;
                    this.updateTextPreview(intermediate, 'plaintextPreview');
                } catch (error) {
                    console.error("Ошибка дешифрования:", error);
                    alert(`Ошибка дешифрования: ${error.message}`);
                }
            }

            singleRoundDecrypt(text, round) {
                let stepsHTML = '';
                let coordinates = [];
                let skippedChars = [];
                
                // Generate coordinate table
                let coordTable = `
                    <table class="process-table">
                        <thead>
                            <tr>
                                <th>Символ</th>
                                <th>XYZ (x,y,z)</th>
                                <th>WXWYWZ (wx,wy,wz)</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                // Find coordinates for each character
                for (let char of text) {
                    const coords = this.find4DCoordinates(char, round);
                    if (coords) {
                        coordinates.push(coords);
                        coordTable += `
                            <tr>
                                <td><code>${this.escapeHtml(char)}</code></td>
                                <td>${coords.xyz.join(',')}</td>
                                <td>${coords.wxwywz.join(',')}</td>
                            </tr>
                        `;
                    } else {
                        skippedChars.push(char);
                        coordTable += `
                            <tr>
                                <td><code>${this.escapeHtml(char)}</code></td>
                                <td colspan="2" class="error">(Не найден в гиперкубах - сохранен)</td>
                            </tr>
                        `;
                    }
                }
                coordTable += `</tbody></table>`;
                stepsHTML += coordTable;

                // Handle case where no characters are in hypercubes
                if (coordinates.length === 0) {
                    return {
                        plaintext: text,
                        steps: stepsHTML + `<p class="warning">Ни один символ не найден в гиперкубах. Дешифрование не выполнено.</p>`
                    };
                }

                // Create full coordinate sequence
                let coordSequence = '';
                for (let coord of coordinates) {
                    coordSequence += coord.xyz.join('') + coord.wxwywz.join('');
                }

                stepsHTML += `
                    <p><strong>Полная последовательность координат:</strong> <code>${this.chunkString(coordSequence, 5)}</code></p>
                `;

                // Split into two equal parts (XYZ and WXWYWZ)
                const partLength = Math.floor(coordSequence.length / 2);
                const xyzPart = coordSequence.substring(0, partLength);
                const wxwywzPart = coordSequence.substring(partLength);

                stepsHTML += `
                    <p><strong>XYZ часть:</strong> <code>${this.chunkString(xyzPart, 5)}</code></p>
                    <p><strong>WXWYWZ часть:</strong> <code>${this.chunkString(wxwywzPart, 5)}</code></p>
                `;

                // Reconstruct plaintext
                let plaintext = '';
                let reconstructionTable = `
                    <table class="process-table">
                        <thead>
                            <tr>
                                <th>Позиция</th>
                                <th>XYZ (x,y,z)</th>
                                <th>WXWYWZ (wx,wy,wz)</th>
                                <th>Символ</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                for (let i = 0; i < xyzPart.length; i += 3) {
                    const x = parseInt(xyzPart[i]);
                    const y = parseInt(xyzPart[i+1]);
                    const z = parseInt(xyzPart[i+2]);
                    
                    const wx = parseInt(wxwywzPart[i]);
                    const wy = parseInt(wxwywzPart[i+1]);
                    const wz = parseInt(wxwywzPart[i+2]);
                    
                    const char = this.getCharFrom4DCoordinates(x, y, z, wx, wy, wz, round);
                    plaintext += char;
                    
                    reconstructionTable += `
                        <tr>
                            <td>${(i/3) + 1}</td>
                            <td>${x},${y},${z}</td>
                            <td>${wx},${wy},${wz}</td>
                            <td><code>${this.escapeHtml(char)}</code></td>
                        </tr>
                    `;
                }
                reconstructionTable += `</tbody></table>`;
                stepsHTML += reconstructionTable;

                // Reinsert skipped characters if any
                if (skippedChars.length > 0) {
                    let originalIndex = 0;
                    let plainIndex = 0;
                    let finalPlaintext = '';
                    
                    for (let char of text) {
                        const coords = this.find4DCoordinates(char, round);
                        if (coords) {
                            if (plainIndex < plaintext.length) {
                                finalPlaintext += plaintext[plainIndex++];
                            } else {
                                finalPlaintext += this.fillerChar;
                            }
                        } else {
                            finalPlaintext += char;
                        }
                    }
                    
                    if (plainIndex < plaintext.length) {
                        finalPlaintext += plaintext.substring(plainIndex);
                    }
                    
                    plaintext = finalPlaintext;
                    
                    stepsHTML += `<p><i class="fas fa-exchange-alt"></i> Восстановлено ${skippedChars.length} сохраненных символов в исходных позициях</p>`;
                }

                return {
                    plaintext: plaintext,
                    steps: stepsHTML
                };
            }

            // ========================
            // Helper Methods
            // ========================

            find4DCoordinates(char, round) {
                if (round >= this.hypercubes.length) return null;
                
                const hypercube = this.hypercubes[round];
                
                // Search in XYZ cube
                for (let x = 0; x < 3; x++) {
                    for (let y = 0; y < 3; y++) {
                        for (let z = 0; z < 3; z++) {
                            if (hypercube.cube1[x][y][z] === char) {
                                // Find corresponding WXWYWZ coordinates
                                for (let wx = 0; wx < 3; wx++) {
                                    for (let wy = 0; wy < 3; wy++) {
                                        for (let wz = 0; wz < 3; wz++) {
                                            if (hypercube.cube2[wx][wy][wz] === char) {
                                                return {
                                                    xyz: [x, y, z],
                                                    wxwywz: [wx, wy, wz]
                                                };
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                return null;
            }

            getCharFrom4DCoordinates(x, y, z, wx, wy, wz, round) {
                if (round >= this.hypercubes.length || 
                    x < 0 || x >= 3 || y < 0 || y >= 3 || z < 0 || z >= 3 ||
                    wx < 0 || wx >= 3 || wy < 0 || wy >= 3 || wz < 0 || wz >= 3) {
                    return this.fillerChar;
                }
                
                // We can use either cube since they contain the same characters
                return this.hypercubes[round].cube1[x][y][z];
            }

            updateTextPreview(text, elementId) {
                if (this.hypercubes.length === 0) {
                    document.getElementById(elementId).innerHTML = '<span class="warning">Сначала инициализируйте гиперкубы</span>';
                    return;
                }

                let previewHtml = '';
                for (const char of text) {
                    const coords = this.find4DCoordinates(char, 0); // Use first hypercube for preview
                    if (coords) {
                        previewHtml += `<span class="char-highlight" title="XYZ: ${coords.xyz.join(',')}, WXWYWZ: ${coords.wxwywz.join(',')}">${this.escapeHtml(char)}</span>`;
                    } else {
                        previewHtml += `<span class="char-skipped" title="Символ не найден в гиперкубах - будет сохранен">${this.escapeHtml(char)}</span>`;
                    }
                }
                document.getElementById(elementId).innerHTML = previewHtml || '<span class="warning">Нет символов для предпросмотра</span>';
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            chunkString(str, size) {
                if (!str) return '';
                const chunks = [];
                for (let i = 0; i < str.length; i += size) {
                    chunks.push(str.substr(i, size));
                }
                return chunks.join(' ');
            }

            loadSampleText(type) {
                const samples = {
                    plain: "SECRET MESSAGE TO ENCRYPT WITH 4D HYPERCIPHER! 12345 @#$%^",
                    cipher: ""
                };

                if (type === 'cipher' && this.hypercubes.length > 0) {
                    samples.cipher = this.generateCiphertext(samples.plain);
                }

                const elementId = type === 'plain' ? 'plaintext' : 'ciphertext';
                const previewId = type === 'plain' ? 'plaintextPreview' : 'ciphertextPreview';
                document.getElementById(elementId).value = samples[type];
                this.updateTextPreview(samples[type], previewId);
            }

            generateCiphertext(text) {
                let ciphertext = '';
                const coordinates = [];
                
                // Use first hypercube for sample generation
                const round = 0;
                
                // Find coordinates for all characters
                for (let char of text) {
                    const coords = this.find4DCoordinates(char, round);
                    if (coords) coordinates.push(coords);
                }
                
                // Create coordinate streams
                const xyzStream = coordinates.map(c => c.xyz.join('')).join('');
                const wxwywzStream = coordinates.map(c => c.wxwywz.join('')).join('');
                const combinedStream = xyzStream + wxwywzStream;
                
                // Generate ciphertext from triplets
                for (let i = 0; i < combinedStream.length; i += 6) {
                    const triplet = combinedStream.substr(i, 6);
                    if (triplet.length === 6) {
                        const x = parseInt(triplet[0]);
                        const y = parseInt(triplet[1]);
                        const z = parseInt(triplet[2]);
                        const wx = parseInt(triplet[3]);
                        const wy = parseInt(triplet[4]);
                        const wz = parseInt(triplet[5]);
                        ciphertext += this.getCharFrom4DCoordinates(x, y, z, wx, wy, wz, round);
                    } else {
                        ciphertext += this.fillerChar;
                    }
                }
                
                return ciphertext;
            }

            // ========================
            // Visualization Methods
            // ========================

            visualizeHypercubes() {
                // Clear previous visualizations
                this.cleanup3DVisualization();
                
                if (this.hypercubes.length === 0) {
                    document.getElementById('hypercube1-display').innerHTML = '<div class="alert alert-warning">Гиперкубы не сгенерированы</div>';
                    document.getElementById('hypercube2-display').innerHTML = '<div class="alert alert-warning">Гиперкубы не сгенерированы</div>';
                    return;
                }

                // Initialize Three.js scenes for both cubes
                this.init3DScene('hypercube1-display', 0xff4444);
                this.init3DScene('hypercube2-display', 0x4444ff);
                
                // Visualize first round hypercubes
                this.visualize3DCube(0, this.hypercubes[0].cube1, 0);
                this.visualize3DCube(1, this.hypercubes[0].cube2, 1);
                
                // Start animation
                this.animate();
            }

            init3DScene(containerId, color) {
                const container = document.getElementById(containerId);
                container.innerHTML = '';
                
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                // Create scene
                const scene = new THREE.Scene();
                
                // Create camera
                const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                camera.position.set(4, 4, 4);
                camera.lookAt(0, 0, 0);
                
                // Create renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                container.appendChild(renderer.domElement);
                
                // Add lights
                const light1 = new THREE.DirectionalLight(0xffffff, 1);
                light1.position.set(1, 1, 1);
                scene.add(light1);
                
                const light2 = new THREE.AmbientLight(0x333333);
                scene.add(light2);
                
                // Store references
                const index = this.scenes.length;
                this.scenes.push(scene);
                this.cameras.push(camera);
                this.renderers.push(renderer);
                this.symbolElements.push([]);
                
                return index;
            }

            visualize3DCube(sceneIndex, cube, cubeType) {
                const scene = this.scenes[sceneIndex];
                const size = 0.8;
                const gap = 0.1;
                
                // Clear previous symbols
                if (this.symbolElements[sceneIndex]) {
                    this.symbolElements[sceneIndex].forEach(el => {
                        if (el.parentNode) el.parentNode.removeChild(el);
                    });
                    this.symbolElements[sceneIndex] = [];
                }
                
                // Create cubes with symbols
                for (let x = 0; x < 3; x++) {
                    for (let y = 0; y < 3; y++) {
                        for (let z = 0; z < 3; z++) {
                            // Create cube mesh
                            const geometry = new THREE.BoxGeometry(size, size, size);
                            const material = new THREE.MeshPhongMaterial({ 
                                color: cubeType === 0 ? 0xff4444 : 0x4444ff,
                                transparent: true,
                                opacity: 0.7
                            });
                            
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.position.set(
                                x - 1 + (x - 1) * gap,
                                y - 1 + (y - 1) * gap,
                                z - 1 + (z - 1) * gap
                            );
                            
                            scene.add(mesh);
                            
                            // Create HTML element for symbol
                            const symbolDiv = document.createElement('div');
                            symbolDiv.className = 'symbol';
                            symbolDiv.textContent = cube[x][y][z];
                            symbolDiv.dataset.coords = `${x},${y},${z}`;
                            symbolDiv.style.color = cubeType === 0 ? '#ff9999' : '#9999ff';
                            
                            const container = document.getElementById(sceneIndex === 0 ? 'hypercube1-display' : 'hypercube2-display');
                            container.appendChild(symbolDiv);
                            
                            this.symbolElements[sceneIndex].push(symbolDiv);
                        }
                    }
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Rotate and render scenes
                for (let i = 0; i < this.scenes.length; i++) {
                    if (this.scenes[i] && this.renderers[i]) {
                        // Rotate scene
                        this.scenes[i].rotation.x += 0.005;
                        this.scenes[i].rotation.y += 0.01;
                        
                        // Render scene
                        this.renderers[i].render(this.scenes[i], this.cameras[i]);
                        
                        // Update symbol positions
                        this.updateSymbolPositions(i);
                    }
                }
            }

            updateSymbolPositions(sceneIndex) {
                const scene = this.scenes[sceneIndex];
                const camera = this.cameras[sceneIndex];
                const symbols = this.symbolElements[sceneIndex];
                const container = document.getElementById(sceneIndex === 0 ? 'hypercube1-display' : 'hypercube2-display');
                
                if (!scene || !camera || !symbols) return;
                
                symbols.forEach((symbol, index) => {
                    const coords = symbol.dataset.coords.split(',').map(Number);
                    const [x, y, z] = coords;
                    
                    // Calculate position (same as in visualize3DCube)
                    const posX = x - 1 + (x - 1) * 0.1;
                    const posY = y - 1 + (y - 1) * 0.1;
                    const posZ = z - 1 + (z - 1) * 0.1;
                    
                    // Create vector and project to screen space
                    const vector = new THREE.Vector3(posX, posY, posZ);
                    vector.project(camera);
                    
                    // Convert to CSS coordinates
                    const xPos = (vector.x * 0.5 + 0.5) * container.clientWidth;
                    const yPos = -(vector.y * 0.5 - 0.5) * container.clientHeight;
                    
                    // Position symbol
                    symbol.style.transform = `translate(${xPos}px, ${yPos}px)`;
                });
            }

            cleanup3DVisualization() {
                // Clean up Three.js resources
                for (let i = 0; i < this.scenes.length; i++) {
                    if (this.scenes[i]) {
                        while(this.scenes[i].children.length > 0) {
                            this.scenes[i].remove(this.scenes[i].children[0]);
                        }
                    }
                    
                    if (this.renderers[i]) {
                        this.renderers[i].dispose();
                        const container = document.getElementById(i === 0 ? 'hypercube1-display' : 'hypercube2-display');
                        if (container && this.renderers[i].domElement.parentNode === container) {
                            container.removeChild(this.renderers[i].domElement);
                        }
                    }
                }
                
                // Clear symbol elements
                this.symbolElements.forEach(symbols => {
                    symbols.forEach(symbol => {
                        if (symbol.parentNode) symbol.parentNode.removeChild(symbol);
                    });
                });
                
                // Reset arrays
                this.scenes = [];
                this.renderers = [];
                this.cameras = [];
                this.symbolElements = [];
            }

            // ========================
            // UI Methods
            // ========================

            updatePasswordStrength(password) {
                let strength = 0;
                const meter = document.getElementById('securityMeter');
                const strengthText = document.getElementById('passwordStrength');
                
                // Reset
                strengthText.querySelectorAll('span').forEach(span => span.classList.remove('active'));
                
                if (!password) {
                    meter.style.width = '0%';
                    return;
                }
                
                // Length check
                if (password.length >= 8) strength++;
                if (password.length >= 12) strength++;
                
                // Complexity checks
                if (/[A-Z]/.test(password)) strength++;
                if (/[a-z]/.test(password)) strength++;
                if (/[0-9]/.test(password)) strength++;
                if (/[^A-Za-z0-9]/.test(password)) strength++;
                
                // Normalize to 1-4 scale
                strength = Math.min(4, Math.max(1, Math.floor(strength / 1.5)));
                
                // Update meter
                meter.style.width = `${strength * 25}%`;
                
                // Update text
                strengthText.querySelector(`span[data-level="${strength}"]`).classList.add('active');
                
                // Color coding
                if (strength <= 1) {
                    meter.style.backgroundColor = this.getThemeColor('error');
                } else if (strength <= 2) {
                    meter.style.backgroundColor = this.getThemeColor('warning');
                } else {
                    meter.style.backgroundColor = this.getThemeColor('success');
                }
            }

            getThemeColor(type) {
                const style = getComputedStyle(document.documentElement);
                return style.getPropertyValue(`--${type}`);
            }

            toggleTheme() {
                const currentTheme = document.body.getAttribute('data-theme') || 'light';
                const newTheme = currentTheme === 'light' ? 'dark' : 'light';
                document.body.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                this.updateThemeIcon(newTheme);
            }

            updateThemeIcon(theme) {
                const icon = document.querySelector('#themeToggle i');
                icon.className = theme === 'light' ? 'fas fa-moon' : 'fas fa-sun';
            }

            resetToDefault() {
                document.getElementById('alphabet').value = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_-+=[]{};:,.<>?';
                document.getElementById('filler').value = '~';
                document.getElementById('encryptionKey').value = '';
                document.getElementById('rounds').value = '5';
                this.encryptionKey = '';
                this.rounds = 5;
                this.hypercubes = [];
                this.cleanup3DVisualization();
                document.getElementById('securityMeter').style.width = '0%';
                document.querySelectorAll('#passwordStrength span').forEach(span => span.classList.remove('active'));
            }

            showError(element, message) {
                element.innerHTML = `<i class="fas fa-exclamation-circle status-icon"></i> ${message}`;
                element.classList.remove('alert-success', 'alert-warning');
                element.classList.add('alert-error');
                element.style.display = 'block';
            }

            showSuccess(element, message) {
                element.innerHTML = `<i class="fas fa-check-circle status-icon"></i> ${message}`;
                element.classList.remove('alert-error', 'alert-warning');
                element.classList.add('alert-success');
                element.style.display = 'block';
            }

            switchTab(tabId) {
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                document.querySelector(`.tab[data-tab="${tabId}"]`).classList.add('active');
                document.getElementById(tabId).classList.add('active');
            }

            async copyToClipboard(elementId, feedbackId) {
                try {
                    const text = document.getElementById(elementId).textContent;
                    await navigator.clipboard.writeText(text);
                    
                    // Show feedback
                    const feedback = document.getElementById(feedbackId);
                    feedback.classList.add('show');
                    setTimeout(() => feedback.classList.remove('show'), 2000);
                } catch (error) {
                    console.error("Copy failed:", error);
                    alert("Не удалось скопировать текст в буфер обмена");
                }
            }

            showAdvancedSettings() {
                const modalHtml = `
                    <div class="modal-overlay">
                        <div class="modal-content">
                            <button class="modal-close">&times;</button>
                            <h3><i class="fas fa-cogs"></i> Расширенные настройки</h3>
                            
                            <div class="form-group">
                                <label for="fillMethod">Метод заполнения кубов:</label>
                                <select id="fillMethod">
                                    <option value="row">По строкам (по умолчанию)</option>
                                    <option value="column">По столбцам</option>
                                    <option value="diagonal">Диагональный</option>
                                    <option value="spiral">Спиральный</option>
                                    <option value="checkerboard">Шахматный</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="saltInput">PBKDF2 Соль</label>
                                <input type="text" id="saltInput" value="${this.salt}">
                                <button class="btn" id="generateSalt">Сгенерировать новую соль</button>
                            </div>
                            
                            <div class="form-group">
                                <label for="iterations">PBKDF2 Итерации (10,000-1,000,000)</label>
                                <input type="number" id="iterations" value="100000" min="10000" max="1000000">
                            </div>
                            
                            <div class="btn-group">
                                <button class="btn" id="saveAdvanced">Сохранить настройки</button>
                                <button class="btn btn-outline" id="cancelAdvanced">Отмена</button>
                            </div>
                        </div>
                    </div>
                `;
                
                const modal = document.createElement('div');
                modal.innerHTML = modalHtml;
                document.body.appendChild(modal);
                
                // Set current values
                modal.querySelector('#fillMethod').value = this.fillMethod;
                modal.querySelector('#iterations').value = 100000;
                
                // Event handlers
                modal.querySelector('#generateSalt').addEventListener('click', () => {
                    this.salt = CryptoJS.lib.WordArray.random(16).toString();
                    modal.querySelector('#saltInput').value = this.salt;
                });
                
                modal.querySelector('#saveAdvanced').addEventListener('click', () => {
                    this.fillMethod = modal.querySelector('#fillMethod').value;
                    this.salt = modal.querySelector('#saltInput').value;
                    modal.remove();
                });
                
                const closeModal = () => modal.remove();
                modal.querySelector('.modal-close').addEventListener('click', closeModal);
                modal.querySelector('#cancelAdvanced').addEventListener('click', closeModal);
                modal.querySelector('.modal-overlay').addEventListener('click', (e) => {
                    if (e.target === modal.querySelector('.modal-overlay')) {
                        closeModal();
                    }
                });
            }
        }

        // Initialize the cipher when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Load Font Awesome if not already loaded
            if (!document.querySelector('#font-awesome')) {
                const fa = document.createElement('link');
                fa.id = 'font-awesome';
                fa.rel = 'stylesheet';
                fa.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css';
                document.head.appendChild(fa);
            }
            
            const cipher = new HyperCipher4D();
        });
    </script>
</body>
</html>
