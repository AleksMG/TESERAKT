<!DOCTYPE html>
<html>
<head>
    <title>4D Trifid Cipher - Fixed Version</title>
    <style>
        body { font-family: Arial; max-width: 800px; margin: 0 auto; padding: 20px }
        .panel { background: #f5f5f5; padding: 20px; margin-bottom: 20px; border-radius: 5px }
        textarea { width: 100%; height: 100px }
        button { padding: 8px 15px; margin: 5px }
        .error { color: red }
        .success { color: green }
        table { border-collapse: collapse; margin: 10px 0 }
        td { width: 30px; height: 30px; border: 1px solid #ccc; text-align: center }
    </style>
</head>
<body>
    <h1>4D Trifid Cipher - Fixed Version</h1>
    
    <div class="panel">
        <h2>Alphabet Configuration</h2>
        <div id="cubes"></div>
        <button onclick="validateAlphabet()">Validate Alphabet</button>
        <div id="validation-result"></div>
    </div>
    
    <div class="panel">
        <h2>Encrypt/Decrypt</h2>
        <textarea id="input" placeholder="Enter text"></textarea><br>
        <button onclick="encrypt()">Encrypt</button>
        <button onclick="decrypt()">Decrypt</button>
        <div id="result"></div>
    </div>

<script>
// Complete 4D alphabet (all cells filled)
const cubes = [
    { // Latin
        layers: [
            ['A','B','C','D','E','F','G','H','I'],
            ['J','K','L','M','N','O','P','Q','R'],
            ['S','T','U','V','W','X','Y','Z','.']
        ]
    },
    { // Cyrillic
        layers: [
            ['А','Б','В','Г','Д','Е','Ж','З','И'],
            ['Й','К','Л','М','Н','О','П','Р','С'],
            ['Т','У','Ф','Х','Ц','Ч','Ш','Щ','Ъ']
        ]
    },
    { // Symbols
        layers: [
            ['1','2','3','4','5','6','7','8','9'],
            ['!','@','#','$','%','^','&','*','('],
            [')','-','+','=','/','?','|','~','§']
        ]
    }
];

const GROUP_SIZE = 3;

// Initialize alphabet display
function init() {
    let html = '';
    cubes.forEach((cube, w) => {
        html += `<h3>Cube ${w+1}</h3>`;
        cube.layers.forEach((layer, z) => {
            html += `<table><caption>Layer ${z+1}</caption><tr>`;
            for (let i = 0; i < 9; i++) {
                if (i % 3 === 0 && i !== 0) html += '</tr><tr>';
                html += `<td>${layer[i]}</td>`;
            }
            html += '</tr></table>';
        });
    });
    document.getElementById('cubes').innerHTML = html;
}

// Validate alphabet
function validateAlphabet() {
    const chars = new Set();
    let emptyCells = 0;
    
    cubes.forEach(cube => {
        cube.layers.forEach(layer => {
            layer.forEach(char => {
                if (!char.trim()) emptyCells++;
                else if (chars.has(char)) {
                    document.getElementById('validation-result').innerHTML = 
                        `<p class="error">Duplicate character found: ${char}</p>`;
                    return;
                }
                chars.add(char);
            });
        });
    });
    
    if (emptyCells > 0) {
        document.getElementById('validation-result').innerHTML = 
            `<p class="error">${emptyCells} empty cells found</p>`;
    } else {
        document.getElementById('validation-result').innerHTML = 
            `<p class="success">Alphabet is valid (${chars.size} unique characters)</p>`;
    }
}

// Find character coordinates
function findChar(c) {
    for (let w = 0; w < cubes.length; w++) {
        for (let z = 0; z < cubes[w].layers.length; z++) {
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    if (cubes[w].layers[z][y*3 + x] === c) {
                        return { x: x+1, y: y+1, z: z+1, w: w+1 };
                    }
                }
            }
        }
    }
    return null;
}

// Encrypt function
function encrypt() {
    const text = document.getElementById('input').value.toUpperCase();
    let encrypted = '';
    
    // Pad text to be divisible by GROUP_SIZE
    const paddedLength = Math.ceil(text.length / GROUP_SIZE) * GROUP_SIZE;
    const paddedText = text.padEnd(paddedLength, ' ');
    
    for (let i = 0; i < paddedText.length; i += GROUP_SIZE) {
        const group = paddedText.substr(i, GROUP_SIZE);
        let coords = [];
        
        // Get coordinates for each character
        for (const char of group) {
            const coord = findChar(char) || { x: 1, y: 1, z: 1, w: 1 };
            coords.push(coord.x, coord.y, coord.z, coord.w);
        }
        
        // Trifid shuffle: [x1,y1,z1,w1, x2,y2,z2,w2, x3,y3,z3,w3]
        // → [x1,x2,x3, y1,y2,y3, z1,z2,z3, w1,w2,w3]
        const shuffled = [];
        for (let j = 0; j < 4; j++) {
            for (let k = 0; k < GROUP_SIZE; k++) {
                shuffled.push(coords[k*4 + j]);
            }
        }
        
        // Convert back to characters
        for (let j = 0; j < shuffled.length; j += 4) {
            const [x,y,z,w] = shuffled.slice(j, j+4);
            encrypted += getChar(x,y,z,w);
        }
    }
    
    document.getElementById('result').innerHTML = 
        `<strong>Ciphertext:</strong> ${encrypted}`;
}

// Decrypt function
function decrypt() {
    const ciphertext = document.getElementById('input').value;
    let decrypted = '';
    
    // Check length is valid
    if (ciphertext.length % (GROUP_SIZE * 4) !== 0) {
        document.getElementById('result').innerHTML = 
            `<p class="error">Ciphertext length must be multiple of ${GROUP_SIZE * 4}</p>`;
        return;
    }
    
    for (let i = 0; i < ciphertext.length; i += GROUP_SIZE * 4) {
        const group = ciphertext.substr(i, GROUP_SIZE * 4);
        let coords = [];
        
        // Get coordinates for each character
        for (const char of group) {
            const coord = findChar(char) || { x: 1, y: 1, z: 1, w: 1 };
            coords.push(coord.x, coord.y, coord.z, coord.w);
        }
        
        // Reverse Trifid shuffle
        const originalCoords = [];
        for (let j = 0; j < GROUP_SIZE; j++) {
            for (let k = 0; k < 4; k++) {
                originalCoords.push(coords[k * GROUP_SIZE + j]);
            }
        }
        
        // Convert back to characters
        for (let j = 0; j < originalCoords.length; j += 4) {
            const [x,y,z,w] = originalCoords.slice(j, j+4);
            decrypted += getChar(x,y,z,w);
        }
    }
    
    document.getElementById('result').innerHTML = 
        `<strong>Plaintext:</strong> ${decrypted.trim()}`;
}

// Get character from coordinates
function getChar(x, y, z, w) {
    w--; z--; y--; x--;
    if (w >= 0 && w < cubes.length && 
        z >= 0 && z < cubes[w].layers.length &&
        y >= 0 && y < 3 && x >= 0 && x < 3) {
        return cubes[w].layers[z][y*3 + x];
    }
    return '?';
}

// Initialize
window.onload = init;
</script>
</body>
</html>
