<!DOCTYPE html>
<html>
<head>
    <title>True 4D Trifid Cipher</title>
    <style>
        body { font-family: Arial; max-width: 800px; margin: 0 auto; padding: 20px }
        .panel { background: #f5f5f5; padding: 20px; margin-bottom: 20px; border-radius: 5px }
        textarea { width: 100%; height: 100px }
        button { padding: 8px 15px; margin: 5px }
        .error { color: red }
        .success { color: green }
        table { border-collapse: collapse; margin: 10px 0 }
        td { width: 30px; height: 30px; border: 1px solid #ccc; text-align: center }
    </style>
</head>
<body>
    <h1>True 4D Trifid Cipher</h1>
    
    <div class="panel">
        <h2>Alphabet Configuration</h2>
        <div id="cubes"></div>
        <button onclick="validateAlphabet()">Validate Alphabet</button>
        <div id="validation-result"></div>
    </div>
    
    <div class="panel">
        <h2>Encrypt/Decrypt</h2>
        <label>Group Size: <input type="number" id="group-size" min="1" max="10" value="5"></label><br>
        <textarea id="input" placeholder="Enter text"></textarea><br>
        <button onclick="encrypt()">Encrypt</button>
        <button onclick="decrypt()">Decrypt</button>
        <div id="result"></div>
    </div>

<script>
// Complete 4D alphabet (all cells filled)
const cubes = [
    { // Latin
        layers: [
            ['A','B','C','D','E','F','G','H','I'],
            ['J','K','L','M','N','O','P','Q','R'],
            ['S','T','U','V','W','X','Y','Z','.']
        ]
    },
    { // Cyrillic
        layers: [
            ['А','Б','В','Г','Д','Е','Ж','З','И'],
            ['Й','К','Л','М','Н','О','П','Р','С'],
            ['Т','У','Ф','Х','Ц','Ч','Ш','Щ','Ъ']
        ]
    },
    { // Symbols
        layers: [
            ['1','2','3','4','5','6','7','8','9'],
            ['!','@','#','$','%','^','&','*','('],
            [')','-','+','=','/','?','|','~','§']
        ]
    }
];

// Initialize alphabet display
function init() {
    let html = '';
    cubes.forEach((cube, w) => {
        html += `<h3>Cube ${w+1}</h3>`;
        cube.layers.forEach((layer, z) => {
            html += `<table><caption>Layer ${z+1}</caption><tr>`;
            for (let i = 0; i < 9; i++) {
                if (i % 3 === 0 && i !== 0) html += '</tr><tr>';
                html += `<td>${layer[i]}</td>`;
            }
            html += '</tr></table>';
        });
    });
    document.getElementById('cubes').innerHTML = html;
}

// Validate alphabet
function validateAlphabet() {
    const chars = new Set();
    let emptyCells = 0;
    
    cubes.forEach(cube => {
        cube.layers.forEach(layer => {
            layer.forEach(char => {
                if (!char.trim()) emptyCells++;
                else if (chars.has(char)) {
                    document.getElementById('validation-result').innerHTML = 
                        `<p class="error">Duplicate character found: ${char}</p>`;
                    return;
                }
                chars.add(char);
            });
        });
    });
    
    if (emptyCells > 0) {
        document.getElementById('validation-result').innerHTML = 
            `<p class="error">${emptyCells} empty cells found</p>`;
    } else {
        document.getElementById('validation-result').innerHTML = 
            `<p class="success">Alphabet is valid (${chars.size} unique characters)</p>`;
    }
}

// Find character coordinates
function findChar(c) {
    for (let w = 0; w < cubes.length; w++) {
        for (let z = 0; z < cubes[w].layers.length; z++) {
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    if (cubes[w].layers[z][y*3 + x] === c) {
                        return { x: x+1, y: y+1, z: z+1, w: w+1 };
                    }
                }
            }
        }
    }
    return null;
}

// Get character from coordinates
function getChar(x, y, z, w) {
    w--; z--; y--; x--;
    if (w >= 0 && w < cubes.length && 
        z >= 0 && z < cubes[w].layers.length &&
        y >= 0 && y < 3 && x >= 0 && x < 3) {
        return cubes[w].layers[z][y*3 + x];
    }
    return '?';
}

// True Trifid encryption with coordinate mixing
function encrypt() {
    const groupSize = parseInt(document.getElementById('group-size').value) || 5;
    const text = document.getElementById('input').value.toUpperCase();
    let encrypted = '';
    
    // Pad text to be divisible by groupSize
    const paddedLength = Math.ceil(text.length / groupSize) * groupSize;
    const paddedText = text.padEnd(paddedLength, ' ');
    
    // Collect all coordinates first
    let allCoords = [];
    for (const char of paddedText) {
        const coord = findChar(char) || { x: 1, y: 1, z: 1, w: 1 };
        allCoords.push(coord.x, coord.y, coord.z, coord.w);
    }
    
    // Split into coordinate streams
    const xCoords = [], yCoords = [], zCoords = [], wCoords = [];
    for (let i = 0; i < allCoords.length; i += 4) {
        xCoords.push(allCoords[i]);
        yCoords.push(allCoords[i+1]);
        zCoords.push(allCoords[i+2]);
        wCoords.push(allCoords[i+3]);
    }
    
    // Concatenate all coordinate streams
    const mixedCoords = [...xCoords, ...yCoords, ...zCoords, ...wCoords];
    
    // Split into new 4-coordinate groups
    for (let i = 0; i < mixedCoords.length; i += 4) {
        const chunk = mixedCoords.slice(i, i+4);
        if (chunk.length === 4) {
            encrypted += getChar(chunk[0], chunk[1], chunk[2], chunk[3]);
        }
    }
    
    document.getElementById('result').innerHTML = 
        `<strong>Ciphertext:</strong> ${encrypted}`;
}

// True Trifid decryption
function decrypt() {
    const groupSize = parseInt(document.getElementById('group-size').value) || 5;
    const ciphertext = document.getElementById('input').value;
    let decrypted = '';
    
    // Check length is valid
    const expectedLength = groupSize * 4;
    if (ciphertext.length % expectedLength !== 0) {
        document.getElementById('result').innerHTML = 
            `<p class="error">Ciphertext length must be multiple of ${expectedLength}</p>`;
        return;
    }
    
    // Get all coordinates from ciphertext
    let allCoords = [];
    for (const char of ciphertext) {
        const coord = findChar(char) || { x: 1, y: 1, z: 1, w: 1 };
        allCoords.push(coord.x, coord.y, coord.z, coord.w);
    }
    
    // Split into original coordinate streams
    const totalCoords = allCoords.length / 4;
    const xCoords = allCoords.slice(0, totalCoords);
    const yCoords = allCoords.slice(totalCoords, totalCoords*2);
    const zCoords = allCoords.slice(totalCoords*2, totalCoords*3);
    const wCoords = allCoords.slice(totalCoords*3);
    
    // Recombine original coordinates
    let originalCoords = [];
    for (let i = 0; i < totalCoords; i++) {
        originalCoords.push(xCoords[i], yCoords[i], zCoords[i], wCoords[i]);
    }
    
    // Convert back to characters
    for (let i = 0; i < originalCoords.length; i += 4) {
        const chunk = originalCoords.slice(i, i+4);
        if (chunk.length === 4) {
            decrypted += getChar(chunk[0], chunk[1], chunk[2], chunk[3]);
        }
    }
    
    document.getElementById('result').innerHTML = 
        `<strong>Plaintext:</strong> ${decrypted.trim()}`;
}

// Initialize
window.onload = init;
</script>
</body>
</html>
