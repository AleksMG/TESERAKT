<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D –®–∏—Ñ—Ä: –ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            background-color: #111;
            color: #eee;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #f44;
            text-align: center;
        }
        .control-panel {
            background-color: #222;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        textarea, input, select, button {
            background-color: #333;
            color: #fff;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 8px;
            margin: 5px 0;
            width: 100%;
        }
        button {
            background-color: #d33;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover {
            background-color: #f55;
        }
        .result {
            background-color: #222;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            white-space: pre-wrap;
        }
        .visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 30px;
        }
        .cube-container {
            flex: 1;
            min-width: 400px;
            height: 400px;
            background-color: #000;
            border-radius: 10px;
            position: relative;
        }
        .info-panel {
            flex: 1;
            min-width: 300px;
            background-color: #222;
            padding: 15px;
            border-radius: 10px;
        }
        .coord-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        .coord-table th, .coord-table td {
            border: 1px solid #444;
            padding: 5px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê 4D –®–∏—Ñ—Ä: –ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è (3√ó3√ó3 √ó 2)</h1>
        
        <div class="control-panel">
            <h2>‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h2>
            <label>–¢–µ–∫—Å—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏:</label>
            <textarea id="text-input" rows="3">HELLO WORLD</textarea>
            
            <div style="display: flex; gap: 10px;">
                <div style="flex: 1;">
                    <label>–ö–ª—é—á –¥–ª—è –ö—É–±–∞ 1:</label>
                    <input type="text" id="key1" value="—Å–µ–∫—Ä–µ—Ç1">
                </div>
                <div style="flex: 1;">
                    <label>–ö–ª—é—á –¥–ª—è –ö—É–±–∞ 2:</label>
                    <input type="text" id="key2" value="—Å–µ–∫—Ä–µ—Ç2">
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button onclick="encrypt()" style="flex: 1;">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                <button onclick="decrypt()" style="flex: 1;">–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                <button onclick="initCubes()" style="flex: 1;">–û–±–Ω–æ–≤–∏—Ç—å –∫—É–±—ã</button>
            </div>
            
            <div style="margin-top: 10px;">
                <label>–ú–µ—Ç–æ–¥ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è:</label>
                <select id="encoding-method">
                    <option value="concat">–ö–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç</option>
                    <option value="compare">–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç</option>
                    <option value="math">–ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏</option>
                </select>
            </div>
        </div>
        
        <div class="result">
            <h3>üìä –†–µ–∑—É–ª—å—Ç–∞—Ç:</h3>
            <div id="output"></div>
        </div>
        
        <h2>üé≤ 4D –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è (–¥–≤–∞ 3D-–∫—É–±–∞)</h2>
        <div class="visualization">
            <div class="cube-container" id="cube1-vis"></div>
            <div class="cube-container" id="cube2-vis"></div>
        </div>
        
        <div class="info-panel">
            <h3>üîç –¢–µ–∫—É—â–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å–∏–º–≤–æ–ª–æ–≤</h3>
            <table class="coord-table">
                <tr>
                    <th>–°–∏–º–≤–æ–ª</th>
                    <th>–ö—É–±1 (x,y,z)</th>
                    <th>–ö—É–±2 (x,y,z)</th>
                    <th>4D-–∫–æ–¥</th>
                </tr>
                <tbody id="coord-table-body"></tbody>
            </table>
            
            <h3 style="margin-top: 20px;">üìù –ê–ª–≥–æ—Ä–∏—Ç–º —Ä–∞–±–æ—Ç—ã:</h3>
            <ol>
                <li>–°–æ–∑–¥–∞–µ–º –¥–≤–∞ 3D-–∫—É–±–∞ 3√ó3√ó3 —Å —Ä–∞–∑–Ω—ã–º–∏ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è–º–∏</li>
                <li>–î–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –Ω–∞—Ö–æ–¥–∏–º —Å–∏–º–≤–æ–ª –≤ –æ–±–æ–∏—Ö –∫—É–±–∞—Ö</li>
                <li>–û–±—ä–µ–¥–∏–Ω—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É –º–µ—Ç–æ–¥—É</li>
                <li>–î–µ—à–∏—Ñ—Ä–æ–≤–∫–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –æ–±—Ä–∞—Ç–Ω—ã–º –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ–º</li>
            </ol>
        </div>
    </div>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let cube1 = [], cube2 = [];
        let scene1, scene2, camera1, camera2, renderer1, renderer2;
        let cubeMeshes1 = [], cubeMeshes2 = [];
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫—É–±–æ–≤ –∏ 3D —Å—Ü–µ–Ω—ã
        function initCubes() {
            // –°–æ–∑–¥–∞–µ–º –∞–ª—Ñ–∞–≤–∏—Ç A-Z + –ø—Ä–æ–±–µ–ª + —Ü–∏—Ñ—Ä—ã + –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª—ã
            const alphabet = [];
            for (let i = 65; i <= 90; i++) alphabet.push(String.fromCharCode(i)); // A-Z
            for (let i = 48; i <= 57; i++) alphabet.push(String.fromCharCode(i)); // 0-9
            alphabet.push(' ', '.', ',', '!', '?');
            
            // –°–æ–∑–¥–∞–µ–º –∫—É–±—ã —Å —Ä–∞–∑–Ω—ã–º–∏ –∫–ª—é—á–∞–º–∏
            cube1 = createCube(alphabet, document.getElementById('key1').value);
            cube2 = createCube(alphabet, document.getElementById('key2').value);
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º 3D –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é
            init3DVisualization();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–±–ª–∏—Ü—É –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
            updateCoordTable();
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ 3D –∫—É–±–∞ —Å –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ–º
        function createCube(alphabet, key) {
            // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –∞–ª—Ñ–∞–≤–∏—Ç —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∫–ª—é—á–∞
            const shuffled = [...alphabet];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const pseudoRandom = (key.charCodeAt(i % key.length) * key.length + i) % shuffled.length;
                const j = pseudoRandom % (i + 1);
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            
            // –°–æ–∑–¥–∞–µ–º 3D –∫—É–± 3x3x3
            const cube = [];
            let index = 0;
            for (let x = 0; x < 3; x++) {
                cube[x] = [];
                for (let y = 0; y < 3; y++) {
                    cube[x][y] = [];
                    for (let z = 0; z < 3; z++) {
                        cube[x][y][z] = shuffled[index++ % shuffled.length];
                    }
                }
            }
            return cube;
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è 3D –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
        function init3DVisualization() {
            // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å—Ü–µ–Ω—ã
            const container1 = document.getElementById('cube1-vis');
            const container2 = document.getElementById('cube2-vis');
            container1.innerHTML = '';
            container2.innerHTML = '';
            
            // –†–∞–∑–º–µ—Ä—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤
            const width = container1.clientWidth;
            const height = container1.clientHeight;
            
            // –°—Ü–µ–Ω–∞ –¥–ª—è –ø–µ—Ä–≤–æ–≥–æ –∫—É–±–∞
            scene1 = new THREE.Scene();
            camera1 = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            renderer1 = new THREE.WebGLRenderer({ antialias: true });
            renderer1.setSize(width, height);
            container1.appendChild(renderer1.domElement);
            
            // –°—Ü–µ–Ω–∞ –¥–ª—è –≤—Ç–æ—Ä–æ–≥–æ –∫—É–±–∞
            scene2 = new THREE.Scene();
            camera2 = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            renderer2 = new THREE.WebGLRenderer({ antialias: true });
            renderer2.setSize(width, height);
            container2.appendChild(renderer2.domElement);
            
            // –ü–æ–∑–∏—Ü–∏—è –∫–∞–º–µ—Ä—ã
            camera1.position.set(4, 4, 4);
            camera1.lookAt(0, 0, 0);
            camera2.position.set(4, 4, 4);
            camera2.lookAt(0, 0, 0);
            
            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const light1 = new THREE.DirectionalLight(0xffcccc, 1);
            light1.position.set(1, 1, 1);
            scene1.add(light1);
            scene1.add(new THREE.AmbientLight(0x333333));
            
            const light2 = new THREE.DirectionalLight(0xccccff, 1);
            light2.position.set(1, 1, 1);
            scene2.add(light2);
            scene2.add(new THREE.AmbientLight(0x333333));
            
            // –û—Å–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç (–¥–ª—è –æ—Ä–∏–µ–Ω—Ç–∏—Ä–∞)
            const axesHelper1 = new THREE.AxesHelper(2);
            scene1.add(axesHelper1);
            const axesHelper2 = new THREE.AxesHelper(2);
            scene2.add(axesHelper2);
            
            // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –∫—É–±—ã
            cubeMeshes1 = [];
            cubeMeshes2 = [];
            
            // –°–æ–∑–¥–∞–µ–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é –∫—É–±–æ–≤
            createCubeVisualization(scene1, cube1, cubeMeshes1, 0xff6666);
            createCubeVisualization(scene2, cube2, cubeMeshes2, 0x6666ff);
            
            // –ê–Ω–∏–º–∞—Ü–∏—è
            animate();
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ 3D –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –∫—É–±–∞
        function createCubeVisualization(scene, cube, meshArray, color) {
            const size = 0.9;
            const gap = 0.1;
            
            // –ú–∞—Ç–µ—Ä–∏–∞–ª –¥–ª—è –∫—É–±–∏–∫–æ–≤
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                specular: 0x111111,
                shininess: 30,
                transparent: true,
                opacity: 0.8
            });
            
            // –°–æ–∑–¥–∞–µ–º 27 –∫—É–±–∏–∫–æ–≤ (3x3x3)
            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        const geometry = new THREE.BoxGeometry(size, size, size);
                        const cubeMesh = new THREE.Mesh(geometry, material.clone());
                        
                        // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∫—É–±–∏–∫
                        cubeMesh.position.set(
                            x - 1 + (x - 1) * gap,
                            y - 1 + (y - 1) * gap,
                            z - 1 + (z - 1) * gap
                        );
                        
                        // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç —Å —Å–∏–º–≤–æ–ª–æ–º
                        const textGeometry = new THREE.TextGeometry(cube[x][y][z], {
                            size: 0.4,
                            height: 0.01,
                            font: 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json'
                        });
                        const textMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                        
                        // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ –∫—É–±–∏–∫–µ
                        textGeometry.computeBoundingBox();
                        const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                        textMesh.position.set(-textWidth/2, -0.2, size/2 + 0.01);
                        
                        // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –∫—É–±–∏–∫ –∏ —Ç–µ–∫—Å—Ç
                        const group = new THREE.Group();
                        group.add(cubeMesh);
                        group.add(textMesh);
                        
                        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ü–≤–µ—Ç
                        group.userData.originalColor = color;
                        group.userData.coords = {x, y, z};
                        group.userData.char = cube[x][y][z];
                        
                        scene.add(group);
                        meshArray.push(group);
                    }
                }
            }
        }
        
        // –ê–Ω–∏–º–∞—Ü–∏—è
        function animate() {
            requestAnimationFrame(animate);
            
            // –í—Ä–∞—â–∞–µ–º –∫—É–±—ã
            cubeMeshes1.forEach(mesh => mesh.rotation.y += 0.005);
            cubeMeshes2.forEach(mesh => mesh.rotation.x += 0.005);
            
            renderer1.render(scene1, camera1);
            renderer2.render(scene2, camera2);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        function updateCoordTable() {
            const tableBody = document.getElementById('coord-table-body');
            tableBody.innerHTML = '';
            
            // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –∏–∑ –æ–±–æ–∏—Ö –∫—É–±–æ–≤
            const allChars = new Set();
            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        allChars.add(cube1[x][y][z]);
                        allChars.add(cube2[x][y][z]);
                    }
                }
            }
            
            // –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—É
            Array.from(allChars).sort().forEach(char => {
                const coords1 = findCharInCube(char, cube1);
                const coords2 = findCharInCube(char, cube2);
                
                if (coords1 && coords2) {
                    const row = document.createElement('tr');
                    
                    const charCell = document.createElement('td');
                    charCell.textContent = char;
                    row.appendChild(charCell);
                    
                    const coords1Cell = document.createElement('td');
                    coords1Cell.textContent = coords1.join(',');
                    row.appendChild(coords1Cell);
                    
                    const coords2Cell = document.createElement('td');
                    coords2Cell.textContent = coords2.join(',');
                    row.appendChild(coords2Cell);
                    
                    const codeCell = document.createElement('td');
                    codeCell.textContent = getEncodedCoords(char, 'concat');
                    row.appendChild(codeCell);
                    
                    tableBody.appendChild(row);
                }
            });
        }
        
        // –ü–æ–∏—Å–∫ —Å–∏–º–≤–æ–ª–∞ –≤ –∫—É–±–µ
        function findCharInCube(char, cube) {
            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        if (cube[x][y][z] === char) {
                            return [x, y, z];
                        }
                    }
                }
            }
            return null;
        }
        
        // –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        function getEncodedCoords(char, method) {
            const coords1 = findCharInCube(char, cube1);
            const coords2 = findCharInCube(char, cube2);
            
            if (!coords1 || !coords2) return null;
            
            switch (method) {
                case 'concat':
                    return coords1.concat(coords2).join(',');
                
                case 'compare':
                    let code = '';
                    for (let i = 0; i < 3; i++) {
                        if (coords1[i] === coords2[i]) code += '=';
                        else if (coords1[i] > coords2[i]) code += '>';
                        else code += '<';
                    }
                    return code;
                
                case 'math':
                    const [x1, y1, z1] = coords1;
                    const [x2, y2, z2] = coords2;
                    return String.fromCharCode(
                        65 + ((x1 * x2 + y1 * y2 + z1 * z2) % 26)
                    );
                
                default:
                    return coords1.concat(coords2).join(',');
            }
        }
        
        // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
        function encrypt() {
            const text = document.getElementById('text-input').value.toUpperCase();
            const method = document.getElementById('encoding-method").value;
            let output = '';
            
            for (const char of text) {
                const encoded = getEncodedCoords(char, method);
                if (encoded) {
                    output += encoded + ' ';
                } else {
                    output += `[${char}?] `;
                }
            }
            
            document.getElementById('output').innerHTML = `
                <strong>–ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç:</strong> ${text}<br>
                <strong>–ú–µ—Ç–æ–¥ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è:</strong> ${document.getElementById('encoding-method').options[document.getElementById('encoding-method').selectedIndex].text}<br>
                <strong>–†–µ–∑—É–ª—å—Ç–∞—Ç:</strong> ${output.trim()}
            `;
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
            highlightChars(text);
        }
        
        // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
        function decrypt() {
            const input = document.getElementById('text-input').value.trim();
            const method = document.getElementById('encoding-method").value;
            let output = '';
            
            // –†–∞–∑–±–∏–≤–∞–µ–º –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω—ã–µ –∫–æ–¥—ã
            const codes = input.split(/\s+/);
            
            for (const code of codes) {
                let char = null;
                
                // –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ —Å–∏–º–≤–æ–ª –ø–æ –∫–æ–¥—É –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –º–µ—Ç–æ–¥–∞
                switch (method) {
                    case 'concat':
                        const coords = code.split(',').map(Number);
                        if (coords.length === 6) {
                            const [x1, y1, z1, x2, y2, z2] = coords;
                            if (x1 >= 0 && x1 < 3 && y1 >= 0 && y1 < 3 && z1 >= 0 && z1 < 3) {
                                char = cube1[x1][y1][z1];
                            }
                        }
                        break;
                    
                    case 'compare':
                        // –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –ø—Ä–æ—Å—Ç–æ –±–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π –ø–æ–¥—Ö–æ–¥—è—â–∏–π —Å–∏–º–≤–æ–ª
                        for (let x = 0; x < 3; x++) {
                            for (let y = 0; y < 3; y++) {
                                for (let z = 0; z < 3; z++) {
                                    const testChar = cube1[x][y][z];
                                    const testCoords = findCharInCube(testChar, cube2);
                                    if (testCoords) {
                                        let testCode = '';
                                        for (let i = 0; i < 3; i++) {
                                            if ([x,y,z][i] === testCoords[i]) testCode += '=';
                                            else if ([x,y,z][i] > testCoords[i]) testCode += '>';
                                            else testCode += '<';
                                        }
                                        if (testCode === code) {
                                            char = testChar;
                                            break;
                                        }
                                    }
                                }
                                if (char) break;
                            }
                            if (char) break;
                        }
                        break;
                    
                    case 'math':
                        const codeValue = code.charCodeAt(0) - 65;
                        for (let x = 0; x < 3; x++) {
                            for (let y = 0; y < 3; y++) {
                                for (let z = 0; z < 3; z++) {
                                    const testChar = cube1[x][y][z];
                                    const testCoords = findCharInCube(testChar, cube2);
                                    if (testCoords) {
                                        const [x2, y2, z2] = testCoords;
                                        if ((x * x2 + y * y2 + z * z2) % 26 === codeValue) {
                                            char = testChar;
                                            break;
                                        }
                                    }
                                }
                                if (char) break;
                            }
                            if (char) break;
                        }
                        break;
                }
                
                output += char || '?';
            }
            
            document.getElementById('output').innerHTML = `
                <strong>–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:</strong> ${input}<br>
                <strong>–ú–µ—Ç–æ–¥ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è:</strong> ${document.getElementById('encoding-method').options[document.getElementById('encoding-method').selectedIndex].text}<br>
                <strong>–†–µ–∑—É–ª—å—Ç–∞—Ç:</strong> ${output}
            `;
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
            highlightChars(output);
        }
        
        // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Å–∏–º–≤–æ–ª–æ–≤ –≤ 3D –∫—É–±–∞—Ö
        function highlightChars(text) {
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ü–≤–µ—Ç–∞ –≤—Å–µ—Ö –∫—É–±–∏–∫–æ–≤
            cubeMeshes1.forEach(mesh => {
                mesh.children[0].material.color.setHex(mesh.userData.originalColor);
            });
            cubeMeshes2.forEach(mesh => {
                mesh.children[0].material.color.setHex(mesh.userData.originalColor);
            });
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —Å–∏–º–≤–æ–ª—ã –∏–∑ —Ç–µ–∫—Å—Ç–∞
            const uniqueChars = [...new Set(text.toUpperCase())];
            uniqueChars.forEach(char => {
                // –í –ø–µ—Ä–≤–æ–º –∫—É–±–µ
                cubeMeshes1.forEach(mesh => {
                    if (mesh.userData.char === char) {
                        mesh.children[0].material.color.setHex(0x00ff00);
                    }
                });
                
                // –í–æ –≤—Ç–æ—Ä–æ–º –∫—É–±–µ
                cubeMeshes2.forEach(mesh => {
                    if (mesh.userData.char === char) {
                        mesh.children[0].material.color.setHex(0x00ff00);
                    }
                });
            });
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.onload = initCubes;
    </script>
</body>
</html>
